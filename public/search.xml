<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022/1/20</title>
    <url>/2021/01/20/2022-1-20/</url>
    <content><![CDATA[<h3 id="最小生成树专题一天"><a href="#最小生成树专题一天" class="headerlink" title="最小生成树专题一天"></a>最小生成树专题一天</h3><h4 id="板子kruskal-2149-「SCOI2005」繁忙的都市-题目-LibreOJ-loj-ac"><a href="#板子kruskal-2149-「SCOI2005」繁忙的都市-题目-LibreOJ-loj-ac" class="headerlink" title="板子kruskal#2149. 「SCOI2005」繁忙的都市 - 题目 - LibreOJ (loj.ac)"></a>板子kruskal<a href="https://loj.ac/p/2149">#2149. 「SCOI2005」繁忙的都市 - 题目 - LibreOJ (loj.ac)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20000</span>;</span><br><span class="line"><span class="keyword">int</span> len , num;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">F</span>(f[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        a[i].u = <span class="built_in">read</span>();</span><br><span class="line">        a[i].v = <span class="built_in">read</span>();</span><br><span class="line">        a[i].w = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">F</span>(a[i].u);</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">F</span>(a[i].v);</span><br><span class="line">        <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">            f[x] = f[y];</span><br><span class="line">            num ++;</span><br><span class="line">            len = <span class="built_in">max</span>(len,a[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="板子primP3366-【模板】最小生成树-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#板子primP3366-【模板】最小生成树-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="板子primP3366 【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>板子prim<a href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">const int N = 2e5 + 11;</span><br><span class="line">int n,m;</span><br><span class="line">struct  node&#123;</span><br><span class="line">    int u,w;</span><br><span class="line">    bool operator &lt; (const node &amp;a) const</span><br><span class="line">    &#123;</span><br><span class="line">        return w&gt;a.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector &lt;node&gt;a[N];</span><br><span class="line">int v[N];</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n = read();m = read();</span><br><span class="line">    for(int i = 1; i &lt;= m; i++)&#123;</span><br><span class="line">        int x,y,z;</span><br><span class="line">        x = read(), y = read(), z = read();</span><br><span class="line">        a[x].push_back((node)&#123;y,z&#125;);</span><br><span class="line">        a[y].push_back((node)&#123;x,z&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    q.push(node&#123;1,0&#125;);</span><br><span class="line">    while(cnt &lt;= n &amp;&amp; q.size())&#123;</span><br><span class="line">        node x = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(v[x.u])continue;</span><br><span class="line">        v[x.u] = 1;</span><br><span class="line">        ans += x.w;</span><br><span class="line">        cnt++;</span><br><span class="line">        for(int i = 0; i &lt; a[x.u].size(); i++)&#123;</span><br><span class="line">            if(!v[a[x.u][i].u])&#123;</span><br><span class="line">                q.push(a[x.u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt &lt; n-1) puts(&quot;orz&quot;);</span><br><span class="line">    else</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断最小生成树路径唯一POJ-1679-The-Unique-MST-poj-org"><a href="#判断最小生成树路径唯一POJ-1679-The-Unique-MST-poj-org" class="headerlink" title="判断最小生成树路径唯一POJ-1679 The Unique MST (poj.org)"></a>判断最小生成树路径唯一<a href="http://poj.org/problem?id=1679">POJ-1679 The Unique MST (poj.org)</a></h4><p><strong>思路</strong></p>
<p>kruskal先跑一遍记录路径 然后依次删掉每条边判断新最小生成树与远最小生成树是否相等</p>
<p>复杂度<em>O(nmlogm)</em> ,待学习新方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//最小生成树是否唯一</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,num,t,sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">F</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">100001</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            a[i].u = <span class="built_in">read</span>();</span><br><span class="line">            a[i].v = <span class="built_in">read</span>();</span><br><span class="line">            a[i].w = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m, cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">F</span>(a[i].u);</span><br><span class="line">            <span class="keyword">int</span> y = <span class="built_in">F</span>(a[i].v);</span><br><span class="line">            <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">                f[x] = y;</span><br><span class="line">                vis[++num] = i;</span><br><span class="line">                sum += a[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++)&#123;</span><br><span class="line">            <span class="built_in">init</span>(n);</span><br><span class="line">            <span class="keyword">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == vis[i])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="built_in">F</span>(a[j].u);</span><br><span class="line">                <span class="keyword">int</span> y = <span class="built_in">F</span>(a[j].v);</span><br><span class="line">                <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">                    f[x] = y;</span><br><span class="line">                    sum2 += a[j].w;</span><br><span class="line">                    num2 ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num2 != num)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(sum2 == sum)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Not Unique!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>训练日志</category>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>训练日志</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 4902 Nice boat线段树</title>
    <url>/2021/10/08/HDU-4902-Nice-boat%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://acm.dingbacode.com/showproblem.php?pid=4902">HDU - 4902</a></p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>对一段序列有两种操作 </p>
<ol>
<li>将区间全部赋成一个值</li>
<li>将区间中大于k的值变成该值与k的gcd</li>
</ol>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>显然这是线段树<br>我们维护一个懒标用来标记该区段是否被赋值，然后正常写线段树就好<br>可以维护一个max来剪枝（不写会出现奇怪的段错误，不明原因）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson x &lt;&lt; 1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson x &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">11</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,same,lazy,maxn;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> same(x) t[x].same</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lazy(x) t[x].lazy</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> maxn(x) t[x].maxn</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b&gt;<span class="number">0</span> ? <span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">maxn</span>(x) = <span class="built_in">max</span>(<span class="built_in">maxn</span>(lson),<span class="built_in">maxn</span>(rson));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">same</span>(lson) == <span class="built_in">same</span>(rson))&#123;</span><br><span class="line">        <span class="built_in">same</span>(x) = <span class="built_in">same</span> (lson);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">same</span>(x) = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lazy</span>(x) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">maxn</span>(lson) = <span class="built_in">lazy</span>(x);</span><br><span class="line">        <span class="built_in">maxn</span>(rson) = <span class="built_in">lazy</span>(x);</span><br><span class="line">        <span class="built_in">same</span>(lson) = <span class="built_in">lazy</span>(x);</span><br><span class="line">        <span class="built_in">same</span>(rson) = <span class="built_in">lazy</span>(x);</span><br><span class="line">        <span class="built_in">lazy</span>(lson) = <span class="built_in">lazy</span>(x);</span><br><span class="line">        <span class="built_in">lazy</span>(rson) = <span class="built_in">lazy</span>(x);</span><br><span class="line">        <span class="built_in">lazy</span>(x) = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">l</span>(x) = l;</span><br><span class="line">    <span class="built_in">r</span>(x) = r;</span><br><span class="line">    <span class="built_in">lazy</span>(x) = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="built_in">same</span>(x) = a[l];</span><br><span class="line">        <span class="built_in">maxn</span>(x) = <span class="built_in">same</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lson,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rson,mid + <span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//if(l &gt;r(x)|| l(x) &gt;r)return;</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= <span class="built_in">l</span>(x) &amp;&amp; <span class="built_in">r</span>(x) &lt;= r)&#123;</span><br><span class="line">        <span class="built_in">same</span>(x) = k;</span><br><span class="line">        <span class="built_in">lazy</span>(x) = k;</span><br><span class="line">        <span class="built_in">maxn</span>(x) = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">l</span>(x) + <span class="built_in">r</span>(x)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">change1</span>(lson,l,r,k);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)&#123;</span><br><span class="line">        <span class="built_in">change1</span>(rson,l,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">maxn</span>(x) &lt;= k)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//if(l &gt;r(x)|| l(x) &gt;r)return;</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= <span class="built_in">l</span>(x) &amp;&amp; <span class="built_in">r</span>(x) &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">same</span>(x) != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//if(same(x) &gt; k)&#123;</span></span><br><span class="line">                <span class="built_in">same</span>(x) = <span class="built_in">gcd</span>(<span class="built_in">maxn</span>(x),k);</span><br><span class="line">                <span class="built_in">lazy</span>(x) = <span class="built_in">gcd</span>(<span class="built_in">maxn</span>(x),k);</span><br><span class="line">                <span class="built_in">maxn</span>(x) = <span class="built_in">gcd</span>(<span class="built_in">maxn</span>(x),k);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">l</span>(x) + <span class="built_in">r</span>(x)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">change2</span>(lson,l,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)&#123;</span><br><span class="line">        <span class="built_in">change2</span>(rson,l,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">l</span>(x) == <span class="built_in">r</span>(x))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maxn</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">l</span>(x) + <span class="built_in">r</span>(x)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(lson,pos);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(rson,pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> op,x,y,z;</span><br><span class="line">            cin &gt;&gt; op &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">change1</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">change2</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,i));</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>个人近几天写线段树易犯的错误：<br>将lson 写成 rson</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-1679 The Unique MST</title>
    <url>/2022/01/21/POJ-1679-TheUniqueMST/</url>
    <content><![CDATA[<h4 id="判断最小生成树路径唯一"><a href="#判断最小生成树路径唯一" class="headerlink" title="判断最小生成树路径唯一"></a>判断最小生成树路径唯一</h4><h4 id="POJ-1679-The-Unique-MST-poj-org"><a href="#POJ-1679-The-Unique-MST-poj-org" class="headerlink" title="POJ-1679 The Unique MST (poj.org)"></a><a href="http://poj.org/problem?id=1679">POJ-1679 The Unique MST (poj.org)</a></h4><p><strong>思路</strong></p>
<p>kruskal先跑一遍记录路径 然后依次删掉每条边判断新最小生成树与远最小生成树是否相等</p>
<p>复杂度<em>O(nmlogm)</em> ,待学习新方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//最小生成树是否唯一</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,num,t,sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">F</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">100001</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            a[i].u = <span class="built_in">read</span>();</span><br><span class="line">            a[i].v = <span class="built_in">read</span>();</span><br><span class="line">            a[i].w = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m, cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">F</span>(a[i].u);</span><br><span class="line">            <span class="keyword">int</span> y = <span class="built_in">F</span>(a[i].v);</span><br><span class="line">            <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">                f[x] = y;</span><br><span class="line">                vis[++num] = i;</span><br><span class="line">                sum += a[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++)&#123;</span><br><span class="line">            <span class="built_in">init</span>(n);</span><br><span class="line">            <span class="keyword">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == vis[i])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="built_in">F</span>(a[j].u);</span><br><span class="line">                <span class="keyword">int</span> y = <span class="built_in">F</span>(a[j].v);</span><br><span class="line">                <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">                    f[x] = y;</span><br><span class="line">                    sum2 += a[j].w;</span><br><span class="line">                    num2 ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num2 != num)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(sum2 == sum)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Not Unique!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>学到一种新方法</strong></p>
<p>考虑最小生成树的唯一性。如果一条边 <strong>不在最小生成树的边集中</strong>，并且可以替换与其 <strong>权值相同、并且在最小生成树边集</strong> 的另一条边。那么，这个最小生成树就是不唯一的。</p>
<p>证明方法kruskal</p>
<p>对于已连接的边集<em>E</em> ,考虑下一条加入的边<em>v</em>,若存在另一条边<em>v1</em>，v1 &gt; v || v1 &lt; v时，v1都不可能是下一条加入的边。</p>
<p>所以只需要考虑当前边长度相同的边即可</p>
<p>由于使用了单调队列所以复杂度和kruskal相同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100001</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;;</span><br><span class="line">node a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">F</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            a[i].u = <span class="built_in">read</span>();</span><br><span class="line">            a[i].v = <span class="built_in">read</span>();</span><br><span class="line">            a[i].w = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m, cmp);</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>, num = <span class="number">0</span>, flag = <span class="number">0</span>,tail = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; tail)&#123;<span class="comment">//tail记录最后长度相同的边的指针</span></span><br><span class="line">                <span class="comment">//sum2记录可以合并的长度相同的边数</span></span><br><span class="line">                <span class="comment">//sum1记录实际最小生成树中连接的边数</span></span><br><span class="line">                <span class="comment">//如果两个不相等说明有可以替换的边，则最小生成树不唯一</span></span><br><span class="line">                <span class="keyword">if</span>(sum1 != sum2)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum1 = <span class="number">0</span>;</span><br><span class="line">                sum2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= m + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j].w != a[i].w)&#123;</span><br><span class="line">                        tail = j - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">F</span>(a[j].u) != <span class="built_in">F</span>(a[j].v))&#123;</span><br><span class="line">                        sum2++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; m)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">F</span>(a[i].u);</span><br><span class="line">            <span class="keyword">int</span> y = <span class="built_in">F</span>(a[i].v);</span><br><span class="line">            <span class="keyword">if</span>(x != y &amp;&amp; num != n<span class="number">-1</span>)&#123;</span><br><span class="line">                f[x] = y;</span><br><span class="line">                num ++;</span><br><span class="line">                sum1++;</span><br><span class="line">                ans += a[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Not Unique!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing - 348 走廊泼水节</title>
    <url>/2021/10/18/acwing-348-%E8%B5%B0%E5%BB%8A%E6%B3%BC%E6%B0%B4%E8%8A%82/</url>
    <content><![CDATA[<p><a href="https://www.acwing.com/problem/content/348/">链接</a></p>
<h5 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h5><p>给定一棵 N 个节点的树，要求增加若干条边，把这棵树扩充为完全图，并满足图的唯一最小生成树仍然是这棵树。求增加的边的权值总和最小是多少。</p>
<h5 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h5><p>完全图</p>
<p>在图论的数学领域，完全图是一个<strong>简单的无向图</strong>，其中每对不同的顶点之间都恰连有一条边相连。</p>
<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>根据Kruskal算法的原理，任何一棵最小生成树一定包含无向图中权值最小的边。所以要保证当前的树是补充完后的完全图的最小生成树，我们每次在两个并查集之间加的边都要比当前边要大1， 我们要增加的边数等于两个并查集的节点数的乘积-1，通过Kruskal算法遍历原图生成最小生成树时添加边即可ac</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>s表示并查集中的节点数</p>
<p>f表示父亲节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;a[<span class="number">6011</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">6011</span>],s[<span class="number">6011</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.z &lt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> f[x] = <span class="built_in">F</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">            s[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n, cmp);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="built_in">F</span>(a[i].x);</span><br><span class="line">            <span class="keyword">int</span> v = <span class="built_in">F</span>(a[i].y);</span><br><span class="line">            <span class="keyword">int</span> w = a[i].z;</span><br><span class="line">            <span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">                f[u] = v;</span><br><span class="line">                ans += (s[v] * s[u] - <span class="number">1</span>) * (w + <span class="number">1</span>);</span><br><span class="line">                s[v] += s[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu - 1886 滑动窗口</title>
    <url>/2021/10/05/luogu-1886-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1886">滑动窗口</a><br>head tail维护单调队列中的队首和队尾 发现新元素<br>枚举i来遍历整个数列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> qx[N],qn[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmax</span><span class="params">()</span></span>&#123;<span class="comment">//求最大值,保持队列单减,保证队首最大</span></span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>,tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head &lt;= tail &amp;&amp; a[qx[tail]] &lt;= a[i])   tail--;</span><br><span class="line">        <span class="comment">//找到前k个数中的最值 一旦遇到了破环队列单调性的值 就清空数列</span></span><br><span class="line">        <span class="comment">//遇到大的就不符合</span></span><br><span class="line">        qx[++tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i++)&#123;<span class="comment">//同理</span></span><br><span class="line">        <span class="keyword">while</span>(head &lt;= tail &amp;&amp; a[qx[tail]] &lt;= a[i])   tail--;</span><br><span class="line">        qx[++tail] = i;</span><br><span class="line">        <span class="keyword">while</span>(qx[head] &lt;= (i - k))&#123;<span class="comment">//因为题目中限制区间长度为k,队首位置超出区间也要出队</span></span><br><span class="line">            head ++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; a[qx[head]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>,tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head &lt;= tail &amp;&amp; a[qn[tail]] &gt;= a[i])   tail--;</span><br><span class="line">        qn[++tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head &lt;= tail &amp;&amp; a[qx[tail]] &gt;= a[i])   tail--;</span><br><span class="line">        qn[++tail] = i;</span><br><span class="line">        <span class="keyword">while</span>(qn[head] &lt;= (i - k))&#123;</span><br><span class="line">            head ++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; a[qn[head]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getmin</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">getmax</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu - 2698 [USACO12MAR]Flowerpot S</title>
    <url>/2021/10/05/luogu-2698-USACO12MAR-Flowerpot-S/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2698">洛谷P2698 [USACO12MAR]Flowerpot S</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,d;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;a[N];</span><br><span class="line"><span class="keyword">int</span> q1[N];</span><br><span class="line"><span class="keyword">int</span> q2[N];</span><br><span class="line"><span class="keyword">int</span> h1,h2,t1,t2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i].first &gt;&gt; a[i].second ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    h1 = h2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h1 &lt;= t1 &amp;&amp; q1[h1] &lt; l)h1++;<span class="comment">//维护区间 如果队首在左端点左边就右移</span></span><br><span class="line">        <span class="keyword">while</span>(h2 &lt;= t2 &amp;&amp; q2[h2] &lt; l)h2++;</span><br><span class="line">        <span class="keyword">while</span>(a[q1[h1]].second - a[q2[h2]].second &lt; d &amp;&amp; r &lt; n)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">while</span>(h1 &lt;= t1 &amp;&amp; a[q1[t1]].second &lt; a[r].second)t1--;<span class="comment">//注意是队尾和边界比较</span></span><br><span class="line">            q1[++t1] = r;</span><br><span class="line">            <span class="keyword">while</span>(h2 &lt;= t2 &amp;&amp; a[q2[t2]].second &gt; a[r].second)t2--;</span><br><span class="line">            q2[++t2] = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[q1[h1]].second - a[q2[h2]].second &gt;= d)&#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans,a[r].first - a[l].first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans &lt; <span class="number">0x3f3f3f3f</span>)cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/2021/11/15/python/</url>
    <content><![CDATA[<h5 id="组合数据类型"><a href="#组合数据类型" class="headerlink" title="组合数据类型"></a>组合数据类型</h5><p>list  []</p>
<p>tuple  ()</p>
<p>dict – (c++ map)</p>
<blockquote>
<p>word = {‘apple’:’苹果’,’banana’:’香蕉’}</p>
</blockquote>
<blockquote>
<p>scores = {‘小张’:100, ‘小李’:80} </p>
</blockquote>
<blockquote>
<p>grad = {4:’很好’,3: ‘好’,2:’中’,1:’差’,0:’很差’}</p>
</blockquote>
<p>set  {}</p>
<h5 id="list操作"><a href="#list操作" class="headerlink" title="list操作"></a>list操作</h5><p>append</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>切片的语法：[起始:结束:步长] 字符串[start: end: step] </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> s t r i n g</span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">-<span class="number">6</span>-<span class="number">5</span>-<span class="number">4</span>-<span class="number">3</span>-<span class="number">2</span>-<span class="number">1</span></span><br><span class="line">步长为负数时</span><br><span class="line">string = <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line">string[<span class="number">8</span>:<span class="number">2</span>:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;row ol&#x27;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>count</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count</span><br><span class="line">string.count(<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">string.count(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>find</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string.find(<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"><span class="number">4</span> <span class="comment">#返回第一个位置</span></span><br><span class="line">string.find(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">-<span class="number">1</span> <span class="comment">#没找到返回-1</span></span><br></pre></td></tr></table></figure>

<p>index 同find 找不到报错</p>
<p>split</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;habcal_hascshaic_ as&quot;</span></span><br><span class="line">s.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">[<span class="string">&#x27;habcal&#x27;</span>, <span class="string">&#x27;hascshaic&#x27;</span>, <span class="string">&#x27; as&#x27;</span>]</span><br><span class="line">s.split(<span class="string">&quot;_&quot;</span>,<span class="number">1</span>)</span><br><span class="line">[<span class="string">&#x27;habcal&#x27;</span>, <span class="string">&#x27;hascshaic_ as&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>replace</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_string = <span class="string">&#x27;hello_world&#x27;</span></span><br><span class="line">my_string.replace(<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>strip 去除首尾字符,默认为空格或换行符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;    abcnsj  \n &quot;</span></span><br><span class="line">s.strip()</span><br><span class="line"><span class="string">&quot;abcnsj&quot;</span></span><br></pre></td></tr></table></figure>

<p>变形</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_string.upper()<span class="comment">#全大写</span></span><br><span class="line">my_string.lower()<span class="comment">#全小写</span></span><br><span class="line">my_string.capitalize()<span class="comment">#首字母大写</span></span><br></pre></td></tr></table></figure>

<p>格式化输出</p>
<p>f-string</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;Molly&#x27;</span></span><br><span class="line">hight = <span class="number">170.4</span></span><br><span class="line">score_math = <span class="number">95</span></span><br><span class="line">score_english = <span class="number">89</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;大家好！我叫<span class="subst">&#123;name&#125;</span>，我的身高是<span class="subst">&#123;hight:<span class="number">.3</span>f&#125;</span> cm, 数学成绩<span class="subst">&#123;score_math&#125;</span>分,英语成绩<span class="subst">&#123;score_english&#125;</span>分&quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列学习笔记</title>
    <url>/2021/10/05/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>为了学习单调队列优化dp去了解了前置知识。<br><strong>什么是单调队列呢？</strong><br>顾名思义，单调队列的重点分为 “单调” 和 “队列”<br>“单调” 指的是元素的的 “规律”——递增（或递减）<br>“队列” 指的是元素只能从队头和队尾进行操作<br>实际上维护一段变化区间里的单调的序列。</p>
<p>如<a href="https://oi-wiki.org/ds/monotonous-queue/">oiwiki</a>中有下面的例子</p>
<p>原序列为</p>
<blockquote>
<p>1 3 -1 -3 5 3 6 7</p>
</blockquote>
<p>要求的是每连续的 k 个数中的最小值，<br>操作如下</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">队列状态2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1 入队</td>
<td align="center">{1}</td>
</tr>
<tr>
<td align="center">3 比 1 大，3 入队</td>
<td align="center">{1 3}</td>
</tr>
<tr>
<td align="center">-1 比队列中所有元素小，所以清空队列 -1 入队</td>
<td align="center">{-1}</td>
</tr>
<tr>
<td align="center">-3 比队列中所有元素小，所以清空队列 -3 入队</td>
<td align="center">{-3}</td>
</tr>
<tr>
<td align="center">5 比 -3 大，直接入队</td>
<td align="center">{-3 5}</td>
</tr>
<tr>
<td align="center">3 比 5 小，5 出队，3 入队</td>
<td align="center">{-3 3}</td>
</tr>
<tr>
<td align="center">-3 已经在窗体外，所以 -3 出队；6 比 3 大，6 入队</td>
<td align="center">{3 6}</td>
</tr>
<tr>
<td align="center">7 比 6 大，7 入队</td>
<td align="center">{3 6 7}</td>
</tr>
</tbody></table>
<p>总结下来就是:一旦遇到了破环队列单调性的值,就弹出之前队列中的数值,始终保持队列递增的状态.保证队首始终是当前区间里最小的值.</p>
<p><strong>例题</strong></p>
<p><a href="https://wwwttlll.github.io/2021/10/05/luogu-1886-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">滑动窗口</a></p>
<p><a href="https://wwwttlll.github.io/2021/10/05/luogu-2698-USACO12MAR-Flowerpot-S/">USACO12MAR]Flowerpot S</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>图论篇-最短路</title>
    <url>/2021/09/21/%E5%9B%BE%E8%AE%BA%E7%AF%87-%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="1-最短路"><a href="#1-最短路" class="headerlink" title="1. 最短路"></a>1. 最短路</h2><h4 id="DIJKSTRA"><a href="#DIJKSTRA" class="headerlink" title="DIJKSTRA"></a>DIJKSTRA</h4><p>基于贪心的最短路算法<br>（下面的改进版）基本不能跑负环（跑负环会非常慢）</p>
<p>板子题</p>
<p><a href="https://www.luogu.org/problem/P1339">热浪Heat Wave</a></p>
<p><a href="https://www.luogu.org/problem/P3371">单源最短路径（弱化版）</a></p>
<p><a href="https://www.luogu.org/problem/P4779">单源最短路径（标准版）</a></p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, s;</span><br><span class="line">vector&lt;pair&lt;int, int&gt; &gt; a[100020];</span><br><span class="line">priority_queue&lt;pair&lt;int, int&gt; &gt; q; </span><br><span class="line">// first存距离，second存点的标号，方便找到距离最小的点 </span><br><span class="line">int d[100020];</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int x, y, z;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        // x 到 y 边权为 z </span><br><span class="line">        a[x].push_back(make_pair(y, z));</span><br><span class="line">        // a[x]是一个vector，记录从x出发的所有边</span><br><span class="line">    &#125;</span><br><span class="line">    memset(d, 0x3f, sizeof d);</span><br><span class="line">    // 初始化所有距离为无穷大 </span><br><span class="line">    d[s] = 0;</span><br><span class="line">    // 起点距离为0 </span><br><span class="line">    q.push(make_pair(-d[s], s));</span><br><span class="line">    // 默认大根堆，但是我们希望距离小的在堆顶，距离存相反数 </span><br><span class="line">    // 刚开始也可以加入其他点，但是其他点距离都是负无穷</span><br><span class="line">    // 加不加无所谓 </span><br><span class="line">    while (q.size() &gt; 0) &#123;</span><br><span class="line">        // 当队列中还有点的时候 </span><br><span class="line">        pair&lt;int, int&gt; u = q.top();</span><br><span class="line">        // 每次选取距离最小的点出堆 </span><br><span class="line">        q.pop();</span><br><span class="line">        if (-u.first &gt; d[u.second]) &#123;</span><br><span class="line">            // 注意到后面修改一个点的距离</span><br><span class="line">            // 并不删除，而是直接重新入堆</span><br><span class="line">            // 所以如果堆中的距离不是最新版本，就忽略 </span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 事实上，如果没有负权边</span><br><span class="line">        // 当u出堆之后，d[u.second]就再也不会改变了 </span><br><span class="line">        // 如果有负权边，这个算法只会慢，而不会错 </span><br><span class="line">        for (int i = 0; i &lt; a[u.second].size(); i++) &#123;</span><br><span class="line">            // 枚举所有出边</span><br><span class="line">            pair&lt;int, int&gt; e = a[u.second][i];</span><br><span class="line">            // 从 u.second 到 e.first 边长为 e.second </span><br><span class="line">            if (d[e.first] &gt; d[u.second] + e.second) &#123;</span><br><span class="line">                d[e.first] = d[u.second] + e.second;</span><br><span class="line">                // 继续松弛操作 </span><br><span class="line">                q.push(make_pair(-d[e.first], e.first));</span><br><span class="line">                // 直接加入新的而不删除旧的 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        printf(&quot;%d%c&quot;, d[i], i == n ? &#x27;\n&#x27; : &#x27; &#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经验总结 </p>
<pre><code>     vector存图会死的！！！

     vector存图会死的！！！
     
     vector存图会死的！！！
     
     比如下面这一道题
</code></pre>
<p>​<br>   <a href="http://poj.org/problem?id=3013">poj 3013 Big Christmas Tree</a></p>
<p>   最短路树  <del>貌似就是正常的最短路</del><br>   ans等于每个节点的点权*该点到根节点的最短路 即 ans= ∑ d[i]*w[i];</p>
<p>   另外这个题不能用vector存图 会TLE 从此痛改前非只用链式前向星</p>
<p>   Code:<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    Name:Big Christmas Tree</span><br><span class="line">	Author:Liberation</span><br><span class="line">	Description:POJ</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long </span><br><span class="line">inline long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">int t,w[100011];</span><br><span class="line">struct edge&#123;</span><br><span class="line">	int next,to,w;</span><br><span class="line">&#125;edge[100011];</span><br><span class="line">int head[100011];</span><br><span class="line">priority_queue&lt;pair&lt;int ,int &gt; &gt;q;</span><br><span class="line">int d[100011];</span><br><span class="line">int v,e,x,y,z,flag,cnt;</span><br><span class="line">int inf;</span><br><span class="line">int ans;</span><br><span class="line">void add(int x,int y,int z)&#123;</span><br><span class="line">	edge[++cnt].next=head[x];</span><br><span class="line">	edge[cnt].w=z;</span><br><span class="line">	edge[cnt].to=y;</span><br><span class="line">	head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">inline void djk()&#123;</span><br><span class="line">	memset(d,0x3f,sizeof d);</span><br><span class="line">	inf=d[0];</span><br><span class="line">	d[1]=0;</span><br><span class="line">	q.push(make_pair(-d[1],1));</span><br><span class="line">	while(q.size())&#123;</span><br><span class="line">		pair&lt;int ,int &gt;u=q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		if(-u.first&gt;d[u.second])&#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=head[u.second];i;i=edge[i].next )&#123;</span><br><span class="line">			int y=edge[i].to,z=edge[i].w;</span><br><span class="line">			if(d[y ]&gt;d[u.second]+z)&#123;</span><br><span class="line">				d[y]=d[u.second]+z;</span><br><span class="line">				q.push(make_pair(-d[y],y));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    //ios::sync_with_stdio(false);</span><br><span class="line">    t=read();</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	cnt=0; </span><br><span class="line">		//memset(edge,0,sizeof edge);</span><br><span class="line">    	v=read();e=read();</span><br><span class="line">    	for(int i=1;i&lt;=v;i++)&#123;</span><br><span class="line">        	w[i]=read();</span><br><span class="line">			head[i]=-1;</span><br><span class="line">	    &#125;</span><br><span class="line">    	for(int i=1;i&lt;=e;i++)&#123;</span><br><span class="line">	    	x=read();y=read();z=read();</span><br><span class="line">	    	add(x,y,z);</span><br><span class="line">	    	add(y,x,z);</span><br><span class="line">	    &#125;</span><br><span class="line">    	djk();</span><br><span class="line">		flag=0;</span><br><span class="line">		ans=0;</span><br><span class="line">    	for(int i=1;i&lt;=v;i++)&#123;</span><br><span class="line">    		if(d[i]&gt;=inf)&#123;</span><br><span class="line">    			flag=1;</span><br><span class="line">				puts(&quot;No Answer&quot;);</span><br><span class="line">    			break;</span><br><span class="line">			&#125;</span><br><span class="line">			ans+=d[i]*w[i];</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag)&#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h4><p><del>（它已经死了）</del>   会各种被卡，但是真的好理解<br>可以用于判负环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">long long d[200011];</span><br><span class="line">vector&lt;pair&lt;int ,int &gt; &gt;a[200011];</span><br><span class="line">bool v[200011];</span><br><span class="line">int n,m,s;</span><br><span class="line">int x,y,z;</span><br><span class="line">queue&lt;long long&gt;q;</span><br><span class="line">void spfa ()&#123;</span><br><span class="line">	memset(d,0x3f,sizeof d);</span><br><span class="line">	memset(v,0,sizeof v);</span><br><span class="line">	d[s]=0;</span><br><span class="line">	v[s]=1;</span><br><span class="line">	q.push(s);</span><br><span class="line">	while(q.size()&gt;0)&#123;</span><br><span class="line">		int x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		v[x]=0;</span><br><span class="line">		for(int i=0;i&lt;a[x].size();i++)&#123;</span><br><span class="line">			pair&lt;int ,int &gt;u=a[x][i];</span><br><span class="line">			if(d[u.first] &gt; d[x] + u.second )&#123;</span><br><span class="line">				d[u.first] = d[x] + u.second;</span><br><span class="line">				if(!v[u.first] )&#123;</span><br><span class="line">				    q.push(u.first ) ;</span><br><span class="line">				    v[u.first ]=1; </span><br><span class="line">			    &#125;</span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();m=read();s=read();</span><br><span class="line">    d[s]=0;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">    	x=read();y=read();z=read();</span><br><span class="line">    	a[x].push_back(make_pair(y,z));</span><br><span class="line">	&#125;</span><br><span class="line">	spfa();</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(d[i]==4557430888798830399)&#123;</span><br><span class="line">		cout&lt;&lt;2147483647&lt;&lt;&quot; &quot;;</span><br><span class="line">		continue;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		cout&lt;&lt;d[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><p>像是区间DP 各种骚操作</p>
<h5 id="1-求稠密图的最短路-O（n-3）"><a href="#1-求稠密图的最短路-O（n-3）" class="headerlink" title="1.求稠密图的最短路 O（n^3）"></a>1.求稠密图的最短路 O（n^3）</h5><p><a href="https://www.luogu.org/problem/P2888">牛栏</a></p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">319</span>][<span class="number">319</span>];</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;t);</span><br><span class="line">	<span class="built_in">memset</span>(a,<span class="number">20</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		a[x][y]=z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i][j]&amp;&amp;a[i][k]&amp;&amp;a[k][j])&#123;</span><br><span class="line">					a[i][j]=<span class="built_in">min</span>(a[i][j],<span class="built_in">max</span>(a[k][j],a[i][k]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">		<span class="keyword">if</span>(a[x][y]!=<span class="number">336860180</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[x][y]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2传递闭包"><a href="#2传递闭包" class="headerlink" title="2传递闭包"></a>2传递闭包</h5><p><a href="http://poj.org/problem?id=3660">Cow Contest</a></p>
<p>数据很小，也可以直接floyd</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">111</span>][<span class="number">111</span>] ;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		f[x][y]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				f[i][j]|=f[i][k]&amp;f[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">bool</span> can=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i!=j&amp;&amp;f[i][j]==<span class="number">0</span>&amp;&amp;f[j][i]==<span class="number">0</span>)&#123;</span><br><span class="line">				can=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(can)&#123;</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="bitset优化传递闭包"><a href="#bitset优化传递闭包" class="headerlink" title="bitset优化传递闭包"></a>bitset优化传递闭包</h5><p><a href="http://poj.org/problem?id=3275">Ranking the Cows</a></p>
<p>单纯传递闭包会超时(只有50分）<br>暴力floyd代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    Name:Ranking the Cows</span><br><span class="line">	Author:Liberation</span><br><span class="line">	Description:POJ</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">int n,m; </span><br><span class="line">int f[1110][1110];</span><br><span class="line">int ans;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    //ios::sync_with_stdio(false);</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">    	int x,y;</span><br><span class="line">    	x=read();y=read();</span><br><span class="line">    	f[x][y]=1;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int k=1;k&lt;=n;k++)&#123;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">				f[i][j]|=f[i][k]&amp;f[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			if(i==j)&#123;</span><br><span class="line">				if(f[i][j])&#123;</span><br><span class="line">					puts(&quot;-1&quot;);</span><br><span class="line">					return 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(!f[i][j]&amp;&amp;!f[j][i])&#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;(ans-n)/2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为n^3会超时</p>
<p>需要bitset优化</p>
<p>将floyd的最后一层枚举bitset<br>Code</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    Name:Ranking the Cows</span><br><span class="line">	Author:Liberation</span><br><span class="line">	Description:POJ</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">int n,m; </span><br><span class="line">bitset&lt;1005&gt;a[1005];</span><br><span class="line">int ans;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    //ios::sync_with_stdio(false);</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    	a[i][i]=1;//初始化 </span><br><span class="line">	&#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">    	int x,y;</span><br><span class="line">    	x=read();y=read();</span><br><span class="line">    	a[x][y]=1;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int k=1;k&lt;=n;k++)&#123;</span><br><span class="line">	//这里k , i 和原来的floyd一样  </span><br><span class="line">	//因为使用了bitset 优化 每一位相当于原来的j </span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(a[i][k])&#123;</span><br><span class="line">				a[i]|=a[k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		ans+=a[i].count();</span><br><span class="line">		//这里 a[i].count() 统计bitset中为1的个数 </span><br><span class="line">		//相当于f[i][j]=1 的个数 </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;n*(n-1)/2-ans+n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="floyd求最小环"><a href="#floyd求最小环" class="headerlink" title="floyd求最小环"></a>floyd求最小环</h5><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1599">HDU 1599 find the mincost route</a></p>
<p>这题要求最小环的长度<br>我们可以用floyd每次松弛前更新答案</p>
<p>每次枚举k时，枚举所有编号小于k的结点i,j（i≠j≠k），可以得出一个经过i,j,k的可行环:a[i][k]+a[k][j]+dist[i][j]，即i到j的最短路加上i到k、j到k的直接距离（若两点之间没有边则为∞）。</p>
<p>Code</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int Maxn=1001;</span><br><span class="line">int n,m,a[Maxn][Maxn],f[Maxn][Maxn],ans;</span><br><span class="line"> </span><br><span class="line">void init()&#123;//初始化</span><br><span class="line">	memset(a,10,sizeof a);</span><br><span class="line">	int x,y,z;</span><br><span class="line">	for (int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">		a[x][y]=a[y][x]=min(a[x][y],z); </span><br><span class="line">		&#125;</span><br><span class="line">	memcpy(f,a,sizeof a);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void work()&#123;</span><br><span class="line">	ans=0x7fffff;</span><br><span class="line">	for (int k=1;k&lt;=n;k++)&#123;</span><br><span class="line">		for (int i=1;i&lt;k;i++)</span><br><span class="line">			for (int j=1;j&lt;i;j++)</span><br><span class="line">            //这里注意i j小于K</span><br><span class="line">            //因为要枚举k之前的点 </span><br><span class="line">				ans=min(ans,a[i][k]+a[k][j]+f[i][j]);</span><br><span class="line">		for (int i=1;i&lt;=n;i++)</span><br><span class="line">			for (int j=1;j&lt;=n;j++)	</span><br><span class="line">				f[i][j]=min(f[i][j],f[i][k]+f[k][j]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">	while (~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">		init();</span><br><span class="line">		work();</span><br><span class="line">		if (ans==0x7fffff) cout&lt;&lt;&quot;It&#x27;s impossible.\n&quot;;</span><br><span class="line">		   else cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://poj.org/problem?id=1734">Sightseeing trip</a></p>
<p>这题有点毒瘤 求最小环的路径 </p>
<p>所以每次记更新最小的时候都应该更新一遍路径</p>
<p>Code</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define inf 0x7ffffff</span><br><span class="line"></span><br><span class="line">int f[111][111],pre[111][111],a[111][111],print[111];</span><br><span class="line">int n,m,cnt,ans=inf,x,y,z;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			f[i][j]=f[j][i]=a[i][j]=a[j][i]=inf;</span><br><span class="line">			pre[i][j]=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">		a[x][y]=a[y][x]=f[x][y]=f[y][x]=min(a[x][y],z);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void floyd()&#123;</span><br><span class="line">	for(int k=1;k&lt;=n;k++)&#123;</span><br><span class="line">		for(int i=1;i&lt;k;i++)&#123;</span><br><span class="line">			for(int j=i+1;j&lt;k;j++)&#123;</span><br><span class="line">				if(a[i][k]+a[k][j]+f[i][j]&lt;ans)&#123;</span><br><span class="line">					ans=a[i][k]+a[k][j]+f[i][j];</span><br><span class="line">					cnt=0;//更新路径</span><br><span class="line">                    //因为有special judge 所以顺序无所谓</span><br><span class="line">					int t=j;</span><br><span class="line">					while(t!=i)&#123;</span><br><span class="line">						print[++cnt]=t;</span><br><span class="line">						t=pre[i][t];</span><br><span class="line">					&#125;</span><br><span class="line">					print[++cnt]=i;</span><br><span class="line">					print[++cnt]=k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">				if(f[i][k]+f[k][j]&lt;f[i][j])&#123;</span><br><span class="line">					f[i][j]=f[i][k]+f[k][j];</span><br><span class="line">					pre[i][j]=pre[k][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	init();</span><br><span class="line">	floyd();</span><br><span class="line">	if(ans==inf)&#123;</span><br><span class="line">		puts(&quot;No solution.&quot;);</span><br><span class="line">		return  0;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">        printf(&quot;%d&quot;, print[1]);</span><br><span class="line">        for (int i = 2; i &lt;= cnt; i++)</span><br><span class="line">            printf(&quot; %d&quot;, print[i]);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>指针函数调用数组</title>
    <url>/2021/11/07/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><p>数组名是指针常量，指向数组的起始地址。</p>
<p>对于T a[N]，a的类型是T* ,可以将指针赋值成a 使指针指向数组的起始位置</p>
<blockquote>
<p>int a[1000];</p>
<p>int *p = a;</p>
</blockquote>
<p>这也是为什么sort函数是</p>
<blockquote>
<p>sort（a , a + n) //对a[0] 到 a[n-1] 排序</p>
</blockquote>
<p>或者lower_bound</p>
<blockquote>
<p>lower_bound(a , a + n, b) - a</p>
</blockquote>
<p>一维数组作为函数形参有两种写法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"><span class="title">num</span><span class="params">(a)</span></span>;</span><br><span class="line"><span class="comment">//二者等价</span></span><br></pre></td></tr></table></figure>

<p>对形参的数组赋值同样有两种形式如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        b[i]= i;</span><br><span class="line">        *(b + i) = i;<span class="comment">//因为b是指针 对指针所在地址赋值 用 *b = ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>定义二维数组</p>
<blockquote>
<p>T a[n] [m]</p>
</blockquote>
<p>a[i]是一个一维数组 类型是T *</p>
<p>sizeof(a[i]) = sizeof(T) * n</p>
<p>a[i]的地址 = a的起始地址 + i * n * sizeof(T)</p>
<p>调用方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n][<span class="number">3</span>]<span class="comment">//列宽必须一致 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*a)[<span class="number">3</span>])</span><span class="comment">//第二维不能省略</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h5><p>常量名和字符串组名类型都是char*</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span>*)<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hello</p>
<p>h</p>
<p>h</p>
</blockquote>
<p>字符数组表示的字符串可以被修改内容,字符指针表示的数组不能被修改内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">char</span> *p - <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">p[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span><span class="comment">//报错</span></span><br></pre></td></tr></table></figure>



<h5 id="指针数组与数组指针区分"><a href="#指针数组与数组指针区分" class="headerlink" title="指针数组与数组指针区分"></a>指针数组与数组指针区分</h5><p>优先级</p>
<p>() &gt;[] &gt; *</p>
<p>数组指针，定义 int (*p)[n]：</p>
<p>“()”优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>]; <span class="comment">//该语句是定义一个数组指针，指向含4个元素的一维数组。</span></span><br><span class="line"> p=a;        <span class="comment">//将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</span></span><br><span class="line"> p++;       <span class="comment">//该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">5</span>]=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in"><span class="keyword">char</span></span> (*p3)[<span class="number">5</span>] = &amp;a;<span class="comment">//&amp;a 是数组的首地址</span></span><br><span class="line"><span class="built_in"><span class="keyword">char</span></span> (*p4)[<span class="number">5</span>] = a; <span class="comment">//a是数组首元素地址  这里是错误的两边类型不一致</span></span><br><span class="line"><span class="comment">//应该强制类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">char</span> <span class="params">(*p4)</span>[5] </span>=(<span class="built_in"><span class="keyword">char</span></span> (*)[<span class="number">5</span>]) a;</span><br><span class="line">cout &lt;&lt; *p3 &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;(p3) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p4 &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;(p4) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ABCD 0x61fe1b 0x61fe20</p>
<p>ABCD 0x61fe1b 0x61fe20</p>
</blockquote>
<p>指针数组，定义 int *p[n]：</p>
<p>[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p=a；</p>
<p>因为p是个不可知的表示，只存在p[0]、p[1]、p[2]…p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 <em>p=a; 这里</em>p表示指针数组第一个元素的值，a的首地址的值。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>指针</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>显式模板实参</title>
    <url>/2021/12/29/%E6%98%BE%E5%BC%8F%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82/</url>
    <content><![CDATA[<h4 id="函数模-mu-板"><a href="#函数模-mu-板" class="headerlink" title="函数模(mu)板"></a>函数模(mu)板</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//隐式调用</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">swap</span>(a,b);</span><br></pre></td></tr></table></figure>

<p>在一些情况下通过隐式调用编译器无法推演参数类型，这是需要进行显式调用。</p>
<p><strong>显示模板实参</strong>的格式为<strong>在调用模板函数的时候在函数名后用&lt;&gt;尖括号括住要显示的类型</strong></p>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(T a, T b)</span></span>&#123;&#125;</span><br><span class="line"><span class="built_in">h</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//报错</span></span><br><span class="line">h&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">1.1</span>)<span class="comment">//正确写法</span></span><br></pre></td></tr></table></figure>

<p>**对于多个模板参数&lt;&gt;中的类型依次对应每个参数，只能省略掉尾部的实参 **</p>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class a, class b, class c&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get</span><span class="params">(b x, c y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line">get&lt;<span class="keyword">double</span>,<span class="keyword">int</span>&gt;(<span class="number">1.1</span>,<span class="number">1</span>);<span class="comment">//输出1</span></span><br><span class="line">get&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;(<span class="number">1.1</span>,<span class="number">1</span>);<span class="comment">//输出1.1</span></span><br><span class="line">get&lt;<span class="keyword">double</span>,<span class="keyword">int</span>,<span class="keyword">double</span>&gt;(<span class="number">1.1</span>,<span class="number">1.2</span>);<span class="comment">//输出1.2</span></span><br></pre></td></tr></table></figure>

<h4 id="必须使用显性调用的情况"><a href="#必须使用显性调用的情况" class="headerlink" title="必须使用显性调用的情况"></a>必须使用显性调用的情况</h4><h5 id="1-同一个模板实参类型不一致的的情况"><a href="#1-同一个模板实参类型不一致的的情况" class="headerlink" title="1.同一个模板实参类型不一致的的情况"></a>1.同一个模板实参类型不一致的的情况</h5><p>如上上代码段</p>
<h5 id="2-函数返回值类型为模板实参类型"><a href="#2-函数返回值类型为模板实参类型" class="headerlink" title="2.函数返回值类型为模板实参类型"></a>2.函数返回值类型为模板实参类型</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class a, class b, class c&gt;</span></span><br><span class="line"><span class="function">a <span class="title">get</span><span class="params">(b x, c y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这种情况下a的类型无法推演</span></span><br><span class="line">get&lt;<span class="keyword">int</span>,<span class="keyword">double</span>,<span class="keyword">double</span>&gt;(<span class="number">1.1</span>,<span class="number">1.2</span>);<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h5 id="3-应用于模板函数的参数中没有出现模板形参的情况"><a href="#3-应用于模板函数的参数中没有出现模板形参的情况" class="headerlink" title="3.应用于模板函数的参数中没有出现模板形参的情况"></a>3.应用于模板函数的参数中没有出现模板形参的情况</h5>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>c++</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>教主的魔法</title>
    <url>/2021/11/25/%E6%95%99%E4%B8%BB%E7%9A%84%E9%AD%94%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2801">题目链接</a></p>
<p>分块板子题 求数列在[l,r]内的数有多少大于/小于/大于等于/小于等于k</p>
<p>考虑分块做法</p>
<p>新建一个vector，对于每块内的数据排序，然后通过二分找到该块内大于k的数量。</p>
<p>记得初始化时也要排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> id[N],len;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N], size[N], st[N], ed[N];</span><br><span class="line"><span class="comment">//单点 区间标记（类似懒标） 大小 每块开始位置 结束位置</span></span><br><span class="line"><span class="keyword">int</span> n,q; </span><br><span class="line">vector &lt;<span class="keyword">int</span> &gt;v[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size[x]; i++)&#123;</span><br><span class="line">        v[x][i] = a[st[x]+ i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v[x].<span class="built_in">begin</span>(),v[x].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sid = id[l], eid = id[r];</span><br><span class="line">    <span class="keyword">if</span>(sid == eid)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">            a[i] += k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update</span>(sid);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; id[i] == sid; i++)&#123;</span><br><span class="line">        a[i] += k;<span class="comment">//零散单点暴力修改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = sid + <span class="number">1</span>; i &lt; eid; i++)&#123;</span><br><span class="line">        s[i] += k;<span class="comment">//区间标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r; id[i] == eid; i--)&#123;</span><br><span class="line">        a[i] += k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(sid);</span><br><span class="line">    <span class="built_in">update</span>(eid);<span class="comment">//更新后的区间排序 只需要更新零散的区间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//cout &lt;&lt; sid &lt;&lt; &quot; &quot; &lt;&lt; size[sid] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; eid &lt;&lt; &quot; &quot; &lt;&lt; size[eid] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sid = id[l];</span><br><span class="line">    <span class="keyword">int</span> eid = id[r];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(sid == eid)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] + s[sid] &gt;= k)&#123;</span><br><span class="line">                ans ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l ;id[i] == sid; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] + s[sid] &gt;= k)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r; id[i] == eid; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] + s[eid] &gt;= k)&#123;<span class="comment">//单点加上区间标记</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = sid + <span class="number">1</span>; i &lt; eid; i++)&#123;</span><br><span class="line">        ans += v[i].<span class="built_in">end</span>() - <span class="built_in">lower_bound</span>(v[i].<span class="built_in">begin</span>(), v[i].<span class="built_in">end</span>(), k - s[i]);</span><br><span class="line">    &#125;<span class="comment">//二分查找 </span></span><br><span class="line">    <span class="comment">//大于等于 lower_bound</span></span><br><span class="line">    <span class="comment">//大于 upper_bound</span></span><br><span class="line">    <span class="comment">//小于 size - lower_bound</span></span><br><span class="line">    <span class="comment">//小于等于 size - upper_bound</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();q = <span class="built_in">read</span>();</span><br><span class="line">    len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len ; i++)&#123;</span><br><span class="line">        st[i] = n / (len) * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        ed[i] = n / len * i;</span><br><span class="line">        <span class="comment">//这里有两种写法 一个是len + 1 块 把len * len 后面的块放在len + 1块</span></span><br><span class="line">        <span class="comment">//另一种是将 后面的块并入 len 块</span></span><br><span class="line">        <span class="comment">//一开始将两种写法写混了QAQ</span></span><br><span class="line">    &#125;</span><br><span class="line">    ed[len] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)&#123;</span><br><span class="line">        size[i] = ed[i] - st[i] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = st[i]; j &lt;= ed[i]; j++)&#123;</span><br><span class="line">            id[j] = i;</span><br><span class="line">            v[i].<span class="built_in">push_back</span>(a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len; i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(), v[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;<span class="comment">//vector初始化后一定记得排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        x = <span class="built_in">read</span>(); y = <span class="built_in">read</span>(); z = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">add</span>(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="built_in">query</span>(x,y,z);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔问题</title>
    <url>/2021/10/31/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>汉诺塔问题是非常经典的递归问题，之前只知道问题的移动步数的结论是2 ^ n - 1,具体过程并未思考。今天通过做题了解到这是明显的递归，过程如下。</p>
<p>有a b c三根柱子，先从n = 1 的情况开始。先将a 中的盘子移到 c中 ，记作<br>$$<br> f(1,a,c).<br>$$</p>
<p> 如果n = 2呢？显然，我们要先将a 中最上面的一个移到b中，再将a中剩下的一个移到c中， 最后将b中的一个移到c中。</p>
<p>那么操作过程是<br>$$<br>f(1,a,b)  -&gt; f(1,a,c) -&gt;f(1,b,c)<br>$$</p>
<p>将情况推广到n。我们需要将a中的n-1个移入b中 将 a中剩下的1个移入c中 在将b中的n-1个移入c中<br>$$<br>f(n-1,a,b)  -&gt; f(1,a,c) -&gt;f(n-1,b,c)<br>$$<br>发现规律了吗，每次的<br>$$<br>f(n) = 2*f(n-1)+1<br>$$<br>通过递归，我们可以得到f(n-1) 来更新f(n);</p>
<p>最终过程代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> a,<span class="keyword">char</span> b, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c----%c\n&quot;</span>,a,c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(n<span class="number">-1</span>,a,c,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c----%c\n&quot;</span>,a,c);</span><br><span class="line">    <span class="built_in">dfs</span>(n<span class="number">-1</span>,b,a,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt != <span class="number">0</span>)cout &lt;&lt; endl;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="built_in">dfs</span>(n,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题顺序理解</title>
    <url>/2021/09/21/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E9%A1%BA%E5%BA%8F%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>一直以来写背包问题全靠背模板，对于01背包和完全背包的顺序问题一直存疑而不得理解，今天巧合之下明白了01背包倒序而完全背包顺序的原因，特此记录。<br>01背包要求每个物品只能取一次，在二维状态下状态转移方程如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][m], f[i - <span class="number">1</span>][m - w[i]] + v[i]);</span><br></pre></td></tr></table></figure>
<p>f[i][j]表示从前i个物品中选出总重量不超过j的物品的最大价值。<br>由此可见每个状态都来自于前一个物品</p>
<p>而完全背包中， 每个物品可以无限取，在二维状态下状态转移方程如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i][j] = <span class="built_in">max</span>(f[i][j] , f[i - <span class="number">1</span>][j - k * w[i]] + k*v[i]);</span><br></pre></td></tr></table></figure>
<p>当然k的重复计算可以简化<br>过程如下<br><img src="https://img-blog.csdnimg.cn/img_convert/77511d81c8abf5204da97ead1b8845ef.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j],f[i][j - w[i]] + v[i]);</span><br></pre></td></tr></table></figure>
<p>可以看出完全背包的状态来源于之前的自己</p>
<p>在通过滚动数组优化成一维后，两者的唯一差别只有枚举j的顺序<br>01</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = W; j &gt;= w[i]; j--)&#123;</span><br><span class="line">		f[j] = <span class="built_in">max</span>(f[j - w[i]] + v[i], f[j]);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完全</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j =  w[i]; j &lt;= W; j++)&#123;</span><br><span class="line">		f[j] = <span class="built_in">max</span>(f[j - w[i]] + v[i], f[j]);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会这样呢<br>举个例子<br>假设你有一个重为2的物品<br>（图中的数学代表枚举的 j）<br><img src="https://img-blog.csdnimg.cn/img_convert/8a7a155271035e0623ac645a3e85f72e.png#pic_center" alt="在这里插入图片描述"><br>在枚举j的过程中，如果顺序枚举 会先更新j = 2的情况，然后根据j = 2 的情况更新j = 4，同理后面的6，8，10 …这样相当于每个物品可以多次使用，符合完全背包的条件。</p>
<p>而如果倒序枚举 ，会先更新4 然后再更新2 2中的状态与4无关，相当于每个物品只能用一次，符合01 背包。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>dp</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>重载运算符</title>
    <url>/2021/11/07/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><h5 id="n元运算符后有（n-1-个参数"><a href="#n元运算符后有（n-1-个参数" class="headerlink" title="n元运算符后有（n-1)个参数"></a>n元运算符后有（n-1)个参数</h5><h5 id="自增自减运算符重载"><a href="#自增自减运算符重载" class="headerlink" title="自增自减运算符重载"></a>自增自减运算符重载</h5><p>前置++ – 没有参数 当做一元运算符重载</p>
<p>成员函数</p>
<blockquote>
<p>T &amp; operator++()</p>
</blockquote>
<p>全局函数</p>
<blockquote>
<p>T1 &amp; operator ++ (T2)  //访问类的私有成员可以声明为类的友元函数</p>
</blockquote>
<p>后置++– 有一个参数 当做二元运算符重载</p>
<p>成员函数</p>
<blockquote>
<p>T operator++(int)</p>
</blockquote>
<p>全局函数</p>
<blockquote>
<p>T1 operator++(T2， int)</p>
</blockquote>
<p>从这里看出++i 比 i ++ 要快</p>
<blockquote>
<p>++d 相当于d.operator++()</p>
</blockquote>
<blockquote>
<p>d– 相当于operatior–(d,0)</p>
</blockquote>
<h5 id="c-不能把“-gt-”操作符重载为非成员函数"><a href="#c-不能把“-gt-”操作符重载为非成员函数" class="headerlink" title="c++不能把“= [] () -&gt;”操作符重载为非成员函数"></a>c++不能把“= [] () -&gt;”操作符重载为非成员函数</h5>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>c++</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>错题小店&amp;&amp;小结论</title>
    <url>/2021/09/21/%E9%94%99%E9%A2%98%E5%B0%8F%E5%BA%97&amp;&amp;%E5%B0%8F%E7%BB%93%E8%AE%BA/</url>
    <content><![CDATA[<ol>
<li>运算级</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((a[i]-a[i<span class="number">-1</span>])%x==<span class="number">0</span>)&#123;</span><br><span class="line">	cnt--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是先判括号内部运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i]-a[i<span class="number">-1</span>]%x==<span class="number">0</span>)&#123;</span><br><span class="line">	cnt--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则是先%</p>
<p>附<a href="https://blog.csdn.net/sozzled_/article/details/107057075">优先级表</a></p>
<ol start="2">
<li><p>double 与 printf</p>
<p>结论：在c语言中，double类型的读入必须用”%lf”；输出必须用”%f”</p>
<p>解释：double和float的精度是不同的，故存储空间也是不同的，所以如果要读入double类型，必须要用%lf来读入，以免精度丢失。而输出，由于printf中并无对%lf的严格定义，故使用%lf不一定会出现正确结果。那使用%f输出又如何呢？由于c语言中的默认参数提升规则，%f输出的不论是float还是double都会被提升到双精度进行输出，并不会有精度丢失。</p>
</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>错题</tag>
      </tags>
  </entry>
  <entry>
    <title>2022/1/21</title>
    <url>/2022/01/21/2022-1-21/</url>
    <content><![CDATA[<h4 id="3250-–-Bad-Hair-Day-poj-org"><a href="#3250-–-Bad-Hair-Day-poj-org" class="headerlink" title="3250 – Bad Hair Day (poj.org)"></a><a href="http://poj.org/problem?id=3250">3250 – Bad Hair Day (poj.org)</a></h4><p>单调栈板子题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">80111</span>];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)&#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(s.<span class="built_in">size</span>() &amp;&amp; a[i] &gt;= a[s.<span class="built_in">top</span>()])&#123;</span><br><span class="line">            ans += i - s.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        ans += n - x;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断最小生成树路径唯一1679-–-The-Unique-MST-poj-org"><a href="#判断最小生成树路径唯一1679-–-The-Unique-MST-poj-org" class="headerlink" title="判断最小生成树路径唯一1679 – The Unique MST (poj.org)"></a>判断最小生成树路径唯一<a href="http://poj.org/problem?id=1679">1679 – The Unique MST (poj.org)</a></h4><p>还是这道题学到了新方法</p>
<p>考虑最小生成树的唯一性。如果一条边 <strong>不在最小生成树的边集中</strong>，并且可以替换与其 <strong>权值相同、并且在最小生成树边集</strong> 的另一条边。那么，这个最小生成树就是不唯一的。</p>
<p>证明方法kruskal</p>
<p>对于已连接的边集<em>E</em> ,考虑下一条加入的边<em>v</em>,若存在另一条边<em>v1</em>，v1 &gt; v || v1 &lt; v时，v1都不可能是下一条加入的边。</p>
<p>所以只需要考虑当前边长度相同的边即可</p>
<p>由于使用了单调队列所以复杂度和kruskal相同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100001</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;;</span><br><span class="line">node a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">F</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            a[i].u = <span class="built_in">read</span>();</span><br><span class="line">            a[i].v = <span class="built_in">read</span>();</span><br><span class="line">            a[i].w = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m, cmp);</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>, num = <span class="number">0</span>, flag = <span class="number">0</span>,tail = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; tail)&#123;<span class="comment">//tail记录最后长度相同的边的指针</span></span><br><span class="line">                <span class="comment">//sum2记录可以合并的长度相同的边数</span></span><br><span class="line">                <span class="comment">//sum1记录实际最小生成树中连接的边数</span></span><br><span class="line">                <span class="comment">//如果两个不相等说明有可以替换的边，则最小生成树不唯一</span></span><br><span class="line">                <span class="keyword">if</span>(sum1 != sum2)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum1 = <span class="number">0</span>;</span><br><span class="line">                sum2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= m + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j].w != a[i].w)&#123;</span><br><span class="line">                        tail = j - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">F</span>(a[j].u) != <span class="built_in">F</span>(a[j].v))&#123;</span><br><span class="line">                        sum2++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; m)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">F</span>(a[i].u);</span><br><span class="line">            <span class="keyword">int</span> y = <span class="built_in">F</span>(a[i].v);</span><br><span class="line">            <span class="keyword">if</span>(x != y &amp;&amp; num != n<span class="number">-1</span>)&#123;</span><br><span class="line">                f[x] = y;</span><br><span class="line">                num ++;</span><br><span class="line">                sum1++;</span><br><span class="line">                ans += a[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Not Unique!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>训练日志</category>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>训练日志</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoderBeginnerContest235</title>
    <url>/2022/01/19/AtCoderBeginnerContest235/</url>
    <content><![CDATA[<h3 id="ABC235"><a href="#ABC235" class="headerlink" title="ABC235"></a><a href="https://atcoder.jp/contests/abc235">ABC235</a></h3><h4 id="T1-Rotate"><a href="#T1-Rotate" class="headerlink" title="T1 Rotate"></a>T1 <a href="https://atcoder.jp/contests/abc235/tasks/abc235_a">Rotate</a></h4><p><strong>题意</strong></p>
<p>给定一个三位数abc</p>
<p>求 abc + bca + cab 的和</p>
<p><strong>解题过程</strong></p>
<p>暴力求和即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a = n % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = n / <span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> c = n / <span class="number">100</span>;</span><br><span class="line">    sum += a * <span class="number">100</span> + b * <span class="number">10</span> + c;</span><br><span class="line">    sum += b * <span class="number">100</span> + c * <span class="number">10</span> + a;</span><br><span class="line">    sum += c * <span class="number">100</span> + a * <span class="number">10</span> + b;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T2-Climbing-Takahashi"><a href="#T2-Climbing-Takahashi" class="headerlink" title="T2 Climbing Takahashi"></a>T2 <a href="https://atcoder.jp/contests/abc235/tasks/abc235_b">Climbing Takahashi</a></h4><p><strong>题意</strong></p>
<p>一个人站在最左侧向，仅向相邻右侧更高处移动，问最终位置</p>
<p><strong>解题过程</strong></p>
<p>从左向右枚举，直到a[i + 1] &lt;= a[i],此时的i即为答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100111</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; a[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; a[i<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">            f = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f == <span class="number">0</span>)cout &lt;&lt; a[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T3-The-Kth-Time-Query"><a href="#T3-The-Kth-Time-Query" class="headerlink" title="T3 The Kth Time Query"></a>T3 <a href="https://atcoder.jp/contests/abc235/tasks/abc235_c">The Kth Time Query</a></h4><p><strong>题意</strong></p>
<p>给定一个数组A 含有n个元素  <em>A</em> =(<em>a</em>1,<em>a</em>2,…,<em>a**N</em>) ，Q组询问 (x<em>i,<em>k</em>i</em>)  即第k个x出现的位置</p>
<p><strong>解题过程</strong></p>
<p>map大法好，直接用map&lt;pair&lt;int,int&gt;,int&gt;mp;预处理出每种元素的出现位置，然后询问时直接查询。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;vis;</span><br><span class="line">map&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        x = <span class="built_in">read</span>();</span><br><span class="line">        vis[x]++;</span><br><span class="line">        mp[<span class="built_in">make_pair</span>(x,vis[x])] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,k;</span><br><span class="line">        x = <span class="built_in">read</span>(); k = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">find</span>(<span class="built_in">make_pair</span>(x,k)) != mp.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; mp[<span class="built_in">make_pair</span>(x,k)] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="T4-Multiply-and-Rotate"><a href="#T4-Multiply-and-Rotate" class="headerlink" title="T4 Multiply and Rotate"></a>T4 <a href="https://atcoder.jp/contests/abc235/tasks/abc235_d">Multiply and Rotate</a></h4><p>卡题了，WA了两天不明白思路有什么问题QAQ</p>
<p><strong>题意</strong></p>
<p>给定 <em>a</em> ,<em>N</em>  数字<em>x</em> 为1,对<em>x</em>有两种操作</p>
<p>操作1：x = x * a</p>
<p>操作2：将x的最右位变成最左位 如123 变成 312</p>
<p>问将<em>x</em>变为<em>N</em>的最小步数</p>
<p><strong>解题过程</strong></p>
<p>map大法好，直接用map&lt;pair&lt;int,int&gt;,int&gt;mp;预处理出每种元素的出现位置，然后询问时直接查询。</p>
<p>可以看出搜索可以解决问题，先写了dfs但是感觉复杂度过不过去，</p>
<p>可以考虑两个优化操作</p>
<p>如果使用bfs对于已经得到结果可以终止搜索，先得到的结果必定是最优解，并且对于已经搜索过的值可以不用重复搜索。</p>
<p>我本来想的是倒着从N开始搜索到1 (<del>WA了两天，始终有2个点过不去</del>)</p>
<p>后来考虑到有这样一种情况 </p>
<blockquote>
<p>5 25 52 260 26 62 310</p>
</blockquote>
<p>如果一个数字末尾是0 那么把0放在开头相当于 x/=10.如果倒着搜索的话需要对每个值都*10再判断，计算量明显高于正向搜索</p>
<p>所以从1向N搜索，以题意模拟即可AC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">#define int long long</span><br><span class="line">map&lt;int,int&gt;mp;</span><br><span class="line">map&lt;int,int&gt;vis;</span><br><span class="line">int a,n;</span><br><span class="line">int pw[20];</span><br><span class="line">int ans = 1e9;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    a = read(); n = read();</span><br><span class="line">    pw[0] = 1;</span><br><span class="line">    pw[1] = 10;</span><br><span class="line">    for(int i = 2; i &lt; 20; i++)&#123;</span><br><span class="line">        pw[i] = pw[i-1] * 10;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    q.push(1);</span><br><span class="line">    vis[1] = 1;</span><br><span class="line">    mp[1] = 0;</span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        int x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(x == n)&#123;</span><br><span class="line">            ans = min(mp[x],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        if(x * a &lt;= 1e6 + 5)&#123;</span><br><span class="line">            if(vis.find(x * a) == vis.end())&#123;</span><br><span class="line">                //cout &lt;&lt; x &lt;&lt; &quot; &quot;&lt;&lt; mp[x] &lt;&lt; &quot; &quot; &lt;&lt; x/a &lt;&lt; &quot; &quot; &lt;&lt; mp[x/a] &lt;&lt; endl;</span><br><span class="line">                vis[x * a] = 1;</span><br><span class="line">                mp[x * a] = mp[x] + 1; </span><br><span class="line">                q.push(x * a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x % 10 != 0 &amp;&amp; x &gt;= 10)&#123;</span><br><span class="line">            int len = log10(x);</span><br><span class="line">            int y = x / 10 + x % 10 * pw[len];</span><br><span class="line">            if(vis.find(y) == vis.end())&#123;</span><br><span class="line">                mp[y] = mp[x] + 1;</span><br><span class="line">                vis[y] = 1;</span><br><span class="line">                //cout &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; mp[y] &lt;&lt; endl;</span><br><span class="line">                q.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans != 1e9)</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    else cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T5-MST-1"><a href="#T5-MST-1" class="headerlink" title="T5 MST + 1"></a>T5 <a href="https://atcoder.jp/contests/abc235/tasks/abc235_e">MST + 1</a></h4><p><strong>题意</strong></p>
<p>给定一个<em>n</em>个节点<em>m</em>条边的无向图，<em>Q</em>次询问。每次询问给定一条新边，问如果原图加入新边，最小生成树是否包括新边。</p>
<p><strong>解题过程</strong></p>
<p>Ashen教了种很简单的做法，就是离线把所有边(包括新边)构建最小生成树，然后对于新加入的边只标记，不连接，这样构建最小生成树的同时能标记下比原图更优的边</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000020</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w,id;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N],v[N],id[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] != x)&#123;</span><br><span class="line">        <span class="keyword">return</span> f[x] = <span class="built_in">F</span>(f[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q;</span><br><span class="line">    n = <span class="built_in">read</span>();m = <span class="built_in">read</span>();q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        a[i].u = <span class="built_in">read</span>(); a[i].v = <span class="built_in">read</span>();</span><br><span class="line">        a[i].w = <span class="built_in">read</span>();</span><br><span class="line">        id[i] = i;</span><br><span class="line">        a[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        a[i + m].u = <span class="built_in">read</span>(); a[i + m].v = <span class="built_in">read</span>();</span><br><span class="line">        a[i + m].w = <span class="built_in">read</span>();</span><br><span class="line">        a[i + m].id = i + m;</span><br><span class="line">        id[i + m] = i + m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m + q, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[i].u;</span><br><span class="line">        <span class="keyword">int</span> y = a[i].v;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">F</span>(x) != <span class="built_in">F</span>(y))&#123;</span><br><span class="line">            v[a[i].id] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i].id &gt; m)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[<span class="built_in">F</span>(x)] = <span class="built_in">F</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[id[i + m]] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然遇到最小生成树了不妨开个专题</p>
<p>未完待续QwQ</p>
]]></content>
      <categories>
        <category>训练日志</category>
        <category>比赛日志</category>
      </categories>
      <tags>
        <tag>训练日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 751 Div2</title>
    <url>/2021/10/25/CodeforcesRound751Div2/</url>
    <content><![CDATA[<p>蒟蒻过菜，只A了两题，在大佬的帮助下A掉C题。</p>
<h4 id="A-Two-Subsequences"><a href="#A-Two-Subsequences" class="headerlink" title="A Two Subsequences"></a>A Two Subsequences</h4><p>题意 ： 给定一个字符串s 将字符串拆成两个子串a,b a是字典序最小的子串 b和a能组成s。</p>
<p>思路：显然 a是个最小的字母 ， b是除了a之外的其他字符，扫一遍s找出a即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">char</span> minn = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt; minn)  &#123;</span><br><span class="line">                minn=s[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; minn &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == id)<span class="keyword">continue</span>;</span><br><span class="line">            cout &lt;&lt; s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练日志</category>
        <category>比赛日志</category>
      </categories>
      <tags>
        <tag>训练日志</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-2-4</title>
    <url>/2022/02/04/2022-2-4/</url>
    <content><![CDATA[<p>补题</p>
<p>Round1</p>
<p><a href="https://ac.nowcoder.com/acm/contest/23106/B">炸鸡块君与FIFA22</a></p>
<p>学了学AE学长的线段树做法</p>
<p>线段树第二维表示初始分数%3，因为当前分数是3的整数倍是下场失败分数不变，所以需要时刻统计当前是否为3的整数倍<br>$$<br>tr[x][i] = tr[x &lt;&lt; 1][i] + tr[x &lt;&lt; 1 | 1][((i + tr[x &lt;&lt; 1][i]) % 3 + 3) % 3];<br>$$</p>
<p>这也是这道题的难点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> init[<span class="number">256</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">char</span> c[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">setmenttree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tr[N &lt;&lt; <span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            tr[x][i] = tr[x &lt;&lt; <span class="number">1</span>][i] + tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>][((i + tr[x &lt;&lt; <span class="number">1</span>][i]) % <span class="number">3</span> + <span class="number">3</span>) % <span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">                tr[x][i] = init[c[l]][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">push_up</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; ql || qr &lt; l)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_pair</span>(tr[x][p],((p + tr[x][p%<span class="number">3</span>]) + <span class="number">3</span>) % <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> xx = <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, mid, ql, qr, p);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt;  xx.first &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(xx.second == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> y = <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, xx.second);</span><br><span class="line">        <span class="keyword">if</span>(y.second == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> xx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_pair</span>(xx.first + y.first , y.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init[<span class="string">&#x27;W&#x27;</span>][<span class="number">0</span>] = init[<span class="string">&#x27;W&#x27;</span>][<span class="number">1</span>] = init[<span class="string">&#x27;W&#x27;</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    init[<span class="string">&#x27;D&#x27;</span>][<span class="number">0</span>] = init[<span class="string">&#x27;D&#x27;</span>][<span class="number">1</span>] = init[<span class="string">&#x27;D&#x27;</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    init[<span class="string">&#x27;L&#x27;</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    init[<span class="string">&#x27;L&#x27;</span>][<span class="number">1</span>] = init[<span class="string">&#x27;L&#x27;</span>][<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    n = <span class="built_in">read</span>();q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c + <span class="number">1</span>);</span><br><span class="line">    tree.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r,p;</span><br><span class="line">        l = <span class="built_in">read</span>(); r = <span class="built_in">read</span>(); p = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = p + tree.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,p % <span class="number">3</span>).first;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>训练日志</category>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>训练日志</tag>
      </tags>
  </entry>
  <entry>
    <title>进制-牛客寒假集训营</title>
    <url>/2022/02/20/%E8%BF%9B%E5%88%B6-%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD%E8%90%A5/</url>
    <content><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/contest/23479/B">https://ac.nowcoder.com/acm/contest/23479/B</a><br>来源：牛客网</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>小红拿到了一个长度为 <em>n</em> 的数字串 <em>s</em>（只有 ‘0’ ~ ‘9’ 这十种字符），她有 <em>q</em> 次以下两种操作： </p>
<p> 第一种： 输入1 x y，修改第 <em>x</em> 个字符为 <em>y</em> ，即令 <em>x = y</em></p>
<p>  第二种： 输出 2 x y ，代表查询区间 [x,y]，该区间子串所能表示的某进制的最小值（进制必须合法，且必须是二进制到十进制之间，可以包含前导零），对 1000000007 取模。</p>
<p>例如若查询的子串为 “47”，其能表示的最小值是八进制代表的”47”，其数值为39，因此输出39。如果用十进制表示，则数值47，比39大。 </p>
<p>  例如若查询的子串为 “10000”，其能表示的最小值是二进制代表的”10000”，其数值为16，因此输出16。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>建两种线段树</p>
<p>第一棵求区间最大值，第二种见9棵k进制线段树，求再k进制下的区间和左右区间合并是权值为$x^{len}+y$</p>
<p>还是比较板子的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">char</span> c[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls x * 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs x * 2 + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,mx;</span><br><span class="line">&#125;t[N * <span class="number">4</span> + <span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l ,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[x].l = l;t[x].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        t[x].mx = c[l] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    t[x].mx = <span class="built_in">max</span>(t[ls].mx, t[rs].mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> id,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[x].l == id &amp;&amp; t[x].r == id)&#123;</span><br><span class="line">        t[x].mx = y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[x].l + t[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(id &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">change</span>(ls, id,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id &gt; mid)&#123;</span><br><span class="line">        <span class="built_in">change</span>(rs,id,y);</span><br><span class="line">    &#125;</span><br><span class="line">    t[x].mx = <span class="built_in">max</span>(t[ls].mx , t[rs].mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span> t[x].mx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[x].l + t[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)&#123;</span><br><span class="line">        maxm = <span class="built_in">max</span>(maxm,<span class="built_in">query</span>(ls,l,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)&#123;</span><br><span class="line">        maxm = <span class="built_in">max</span>(maxm,<span class="built_in">query</span>(rs,l,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1000000007</span>;</span><br><span class="line"><span class="function">ll <span class="title">pw</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll re = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            re = re * a % p;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bit</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll sum;</span><br><span class="line">&#125;bt[N * <span class="number">4</span> + <span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitbuild</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r&lt;&lt; endl;</span></span><br><span class="line">    bt[x][b].l = l;</span><br><span class="line">    bt[x][b].r = r;</span><br><span class="line">    <span class="comment">/*if(x == 3)&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; bt[x][b].r &lt;&lt; &quot; &quot; &lt;&lt; bt[x][b].l &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        bt[x][b].sum = c[l] - <span class="string">&#x27;0&#x27;</span>; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bitbuild</span>(ls,l,mid,b);</span><br><span class="line">    <span class="built_in">bitbuild</span>(rs,mid + <span class="number">1</span>,r,b);</span><br><span class="line">    <span class="comment">/*if(x == 1)&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; rs &lt;&lt; &quot; &quot; &lt;&lt; bt[rs][b].r &lt;&lt; &quot; &quot; &lt;&lt; bt[rs][b].l &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">int</span> len = bt[rs][b].r - bt[rs][b].l + <span class="number">1</span>;</span><br><span class="line">    bt[x][b].sum = (bt[ls][b].sum * <span class="built_in">pw</span>(b,len) % p + bt[rs][b].sum) % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitchange</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> id,<span class="keyword">int</span> y,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt[x][b].l == bt[x][b].r &amp;&amp; bt[x][b].r == id)&#123;</span><br><span class="line">        bt[x][b].sum = y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (bt[x][b].l + bt[x][b].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(id &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">bitchange</span>(ls,id,y,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id &gt; mid)&#123;</span><br><span class="line">        <span class="built_in">bitchange</span>(rs,id,y,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = bt[rs][b].r - bt[rs][b].l + <span class="number">1</span>;</span><br><span class="line">    bt[x][b].sum = (bt[ls][b].sum * <span class="built_in">pw</span>(b,len) % p + bt[rs][b].sum) % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">bitquery</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= bt[x][b].l &amp;&amp; bt[x][b].r &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span> bt[x][b].sum % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (bt[x][b].l + bt[x][b].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)&#123;</span><br><span class="line">        sum = <span class="built_in">bitquery</span>(ls,l,r,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; rs &lt;&lt; &quot; &quot; &lt;&lt; bt[rs][x].r &lt;&lt; &quot; &quot; &lt;&lt; bt[rs][x].l &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; endl;</span></span><br><span class="line">        ll sum2 = <span class="built_in">bitquery</span>(rs,l,r,b);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">min</span>(r,bt[rs][b].r)-mid;</span><br><span class="line">        <span class="keyword">return</span> (sum * <span class="built_in">pw</span>(b,len) % p + sum2) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">bitbuild</span>(<span class="number">1</span>,<span class="number">1</span>,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op,x,y;</span><br><span class="line">        op = <span class="built_in">read</span>();x = <span class="built_in">read</span>();y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,x,y);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">                <span class="built_in">bitchange</span>(<span class="number">1</span>,x,y,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mm = <span class="built_in">query</span>(<span class="number">1</span>,x,y);</span><br><span class="line">            mm++;</span><br><span class="line">            <span class="keyword">if</span>(mm == <span class="number">1</span>)&#123;</span><br><span class="line">                mm++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="built_in">bitquery</span>(<span class="number">1</span>,x,y,mm) % p;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            <span class="comment">//printf(&quot;%d\n&quot;,mm);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>

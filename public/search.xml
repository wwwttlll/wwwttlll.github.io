<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022/1/20</title>
    <url>/2021/01/20/2022-1-20/</url>
    <content><![CDATA[<h3 id="最小生成树专题一天"><a href="#最小生成树专题一天" class="headerlink" title="最小生成树专题一天"></a>最小生成树专题一天</h3><h4 id="板子kruskal-2149-「SCOI2005」繁忙的都市-题目-LibreOJ-loj-ac"><a href="#板子kruskal-2149-「SCOI2005」繁忙的都市-题目-LibreOJ-loj-ac" class="headerlink" title="板子kruskal#2149. 「SCOI2005」繁忙的都市 - 题目 - LibreOJ (loj.ac)"></a>板子kruskal<a href="https://loj.ac/p/2149">#2149. 「SCOI2005」繁忙的都市 - 题目 - LibreOJ (loj.ac)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20000</span>;</span><br><span class="line"><span class="keyword">int</span> len , num;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">F</span>(f[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        a[i].u = <span class="built_in">read</span>();</span><br><span class="line">        a[i].v = <span class="built_in">read</span>();</span><br><span class="line">        a[i].w = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">F</span>(a[i].u);</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">F</span>(a[i].v);</span><br><span class="line">        <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">            f[x] = f[y];</span><br><span class="line">            num ++;</span><br><span class="line">            len = <span class="built_in">max</span>(len,a[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="板子primP3366-【模板】最小生成树-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#板子primP3366-【模板】最小生成树-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="板子primP3366 【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>板子prim<a href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">const int N = 2e5 + 11;</span><br><span class="line">int n,m;</span><br><span class="line">struct  node&#123;</span><br><span class="line">    int u,w;</span><br><span class="line">    bool operator &lt; (const node &amp;a) const</span><br><span class="line">    &#123;</span><br><span class="line">        return w&gt;a.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector &lt;node&gt;a[N];</span><br><span class="line">int v[N];</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n = read();m = read();</span><br><span class="line">    for(int i = 1; i &lt;= m; i++)&#123;</span><br><span class="line">        int x,y,z;</span><br><span class="line">        x = read(), y = read(), z = read();</span><br><span class="line">        a[x].push_back((node)&#123;y,z&#125;);</span><br><span class="line">        a[y].push_back((node)&#123;x,z&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    q.push(node&#123;1,0&#125;);</span><br><span class="line">    while(cnt &lt;= n &amp;&amp; q.size())&#123;</span><br><span class="line">        node x = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(v[x.u])continue;</span><br><span class="line">        v[x.u] = 1;</span><br><span class="line">        ans += x.w;</span><br><span class="line">        cnt++;</span><br><span class="line">        for(int i = 0; i &lt; a[x.u].size(); i++)&#123;</span><br><span class="line">            if(!v[a[x.u][i].u])&#123;</span><br><span class="line">                q.push(a[x.u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt &lt; n-1) puts(&quot;orz&quot;);</span><br><span class="line">    else</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断最小生成树路径唯一POJ-1679-The-Unique-MST-poj-org"><a href="#判断最小生成树路径唯一POJ-1679-The-Unique-MST-poj-org" class="headerlink" title="判断最小生成树路径唯一POJ-1679 The Unique MST (poj.org)"></a>判断最小生成树路径唯一<a href="http://poj.org/problem?id=1679">POJ-1679 The Unique MST (poj.org)</a></h4><p><strong>思路</strong></p>
<p>kruskal先跑一遍记录路径 然后依次删掉每条边判断新最小生成树与远最小生成树是否相等</p>
<p>复杂度<em>O(nmlogm)</em> ,待学习新方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//最小生成树是否唯一</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,num,t,sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">F</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">100001</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            a[i].u = <span class="built_in">read</span>();</span><br><span class="line">            a[i].v = <span class="built_in">read</span>();</span><br><span class="line">            a[i].w = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m, cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">F</span>(a[i].u);</span><br><span class="line">            <span class="keyword">int</span> y = <span class="built_in">F</span>(a[i].v);</span><br><span class="line">            <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">                f[x] = y;</span><br><span class="line">                vis[++num] = i;</span><br><span class="line">                sum += a[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++)&#123;</span><br><span class="line">            <span class="built_in">init</span>(n);</span><br><span class="line">            <span class="keyword">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == vis[i])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="built_in">F</span>(a[j].u);</span><br><span class="line">                <span class="keyword">int</span> y = <span class="built_in">F</span>(a[j].v);</span><br><span class="line">                <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">                    f[x] = y;</span><br><span class="line">                    sum2 += a[j].w;</span><br><span class="line">                    num2 ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num2 != num)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(sum2 == sum)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Not Unique!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>训练日志</category>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>训练日志</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>2022/1/21</title>
    <url>/2022/01/21/2022-1-21/</url>
    <content><![CDATA[<h4 id="3250-–-Bad-Hair-Day-poj-org"><a href="#3250-–-Bad-Hair-Day-poj-org" class="headerlink" title="3250 – Bad Hair Day (poj.org)"></a><a href="http://poj.org/problem?id=3250">3250 – Bad Hair Day (poj.org)</a></h4><p>单调栈板子题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">80111</span>];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)&#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(s.<span class="built_in">size</span>() &amp;&amp; a[i] &gt;= a[s.<span class="built_in">top</span>()])&#123;</span><br><span class="line">            ans += i - s.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        ans += n - x;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断最小生成树路径唯一1679-–-The-Unique-MST-poj-org"><a href="#判断最小生成树路径唯一1679-–-The-Unique-MST-poj-org" class="headerlink" title="判断最小生成树路径唯一1679 – The Unique MST (poj.org)"></a>判断最小生成树路径唯一<a href="http://poj.org/problem?id=1679">1679 – The Unique MST (poj.org)</a></h4><p>还是这道题学到了新方法</p>
<p>考虑最小生成树的唯一性。如果一条边 <strong>不在最小生成树的边集中</strong>，并且可以替换与其 <strong>权值相同、并且在最小生成树边集</strong> 的另一条边。那么，这个最小生成树就是不唯一的。</p>
<p>证明方法kruskal</p>
<p>对于已连接的边集<em>E</em> ,考虑下一条加入的边<em>v</em>,若存在另一条边<em>v1</em>，v1 &gt; v || v1 &lt; v时，v1都不可能是下一条加入的边。</p>
<p>所以只需要考虑当前边长度相同的边即可</p>
<p>由于使用了单调队列所以复杂度和kruskal相同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100001</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;;</span><br><span class="line">node a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">F</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            a[i].u = <span class="built_in">read</span>();</span><br><span class="line">            a[i].v = <span class="built_in">read</span>();</span><br><span class="line">            a[i].w = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m, cmp);</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>, num = <span class="number">0</span>, flag = <span class="number">0</span>,tail = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; tail)&#123;<span class="comment">//tail记录最后长度相同的边的指针</span></span><br><span class="line">                <span class="comment">//sum2记录可以合并的长度相同的边数</span></span><br><span class="line">                <span class="comment">//sum1记录实际最小生成树中连接的边数</span></span><br><span class="line">                <span class="comment">//如果两个不相等说明有可以替换的边，则最小生成树不唯一</span></span><br><span class="line">                <span class="keyword">if</span>(sum1 != sum2)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum1 = <span class="number">0</span>;</span><br><span class="line">                sum2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= m + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j].w != a[i].w)&#123;</span><br><span class="line">                        tail = j - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">F</span>(a[j].u) != <span class="built_in">F</span>(a[j].v))&#123;</span><br><span class="line">                        sum2++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; m)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">F</span>(a[i].u);</span><br><span class="line">            <span class="keyword">int</span> y = <span class="built_in">F</span>(a[i].v);</span><br><span class="line">            <span class="keyword">if</span>(x != y &amp;&amp; num != n<span class="number">-1</span>)&#123;</span><br><span class="line">                f[x] = y;</span><br><span class="line">                num ++;</span><br><span class="line">                sum1++;</span><br><span class="line">                ans += a[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Not Unique!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>训练日志</category>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>训练日志</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-2-4</title>
    <url>/2022/02/04/2022-2-4/</url>
    <content><![CDATA[<p>补题</p>
<p>Round1</p>
<p><a href="https://ac.nowcoder.com/acm/contest/23106/B">炸鸡块君与FIFA22</a></p>
<p>学了学AE学长的线段树做法</p>
<p>线段树第二维表示初始分数%3，因为当前分数是3的整数倍是下场失败分数不变，所以需要时刻统计当前是否为3的整数倍<br>$$<br>tr[x][i] = tr[x &lt;&lt; 1][i] + tr[x &lt;&lt; 1 | 1][((i + tr[x &lt;&lt; 1][i]) % 3 + 3) % 3];<br>$$</p>
<p>这也是这道题的难点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> init[<span class="number">256</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">char</span> c[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">setmenttree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tr[N &lt;&lt; <span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            tr[x][i] = tr[x &lt;&lt; <span class="number">1</span>][i] + tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>][((i + tr[x &lt;&lt; <span class="number">1</span>][i]) % <span class="number">3</span> + <span class="number">3</span>) % <span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">                tr[x][i] = init[c[l]][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">push_up</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; ql || qr &lt; l)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">make_pair</span>(tr[x][p],((p + tr[x][p%<span class="number">3</span>]) + <span class="number">3</span>) % <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> xx = <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, mid, ql, qr, p);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt;  xx.first &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(xx.second == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> y = <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, xx.second);</span><br><span class="line">        <span class="keyword">if</span>(y.second == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> xx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_pair</span>(xx.first + y.first , y.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init[<span class="string">&#x27;W&#x27;</span>][<span class="number">0</span>] = init[<span class="string">&#x27;W&#x27;</span>][<span class="number">1</span>] = init[<span class="string">&#x27;W&#x27;</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    init[<span class="string">&#x27;D&#x27;</span>][<span class="number">0</span>] = init[<span class="string">&#x27;D&#x27;</span>][<span class="number">1</span>] = init[<span class="string">&#x27;D&#x27;</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    init[<span class="string">&#x27;L&#x27;</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    init[<span class="string">&#x27;L&#x27;</span>][<span class="number">1</span>] = init[<span class="string">&#x27;L&#x27;</span>][<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    n = <span class="built_in">read</span>();q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c + <span class="number">1</span>);</span><br><span class="line">    tree.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r,p;</span><br><span class="line">        l = <span class="built_in">read</span>(); r = <span class="built_in">read</span>(); p = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = p + tree.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,p % <span class="number">3</span>).first;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>训练日志</category>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>训练日志</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-7-24</title>
    <url>/2022/07/24/2022-7-24/</url>
    <content><![CDATA[<h2 id="牛客多校round1"><a href="#牛客多校round1" class="headerlink" title="牛客多校round1"></a>牛客多校round1</h2><p>队友杀疯了</p>
<p>G 签到题</p>
<p>A 也算签到吧，区间覆盖的easy题，vector排序一下，把不考虑包含在里面的情况就行</p>
<p>D 是计算几何，开始以为直接把线段ab当做弦长时的弧长当做答案，但是wa了,卡了很久一度以为是精度问题，后来证明这个算法是伪命题并通过圆心角和圆周角的关系证明了弦过圆心的时候对应的弧长最大，过了。</p>
<p>了解到精度1e-6可以容受一次反三角函数的运算，直接两个反三角函数求得夹角，然后$l=r\theta$</p>
<p>I 是道概率dp,队友精通麻将并ac了这道题(bushi)赛后补题，摸牌的策略是摸到的牌可以凑成对子就留下，凑不成就舍弃</p>
<h2 id="牛客多校round2"><a href="#牛客多校round2" class="headerlink" title="牛客多校round2"></a>牛客多校round2</h2><p>G 首先想法是奇偶对半分然后糊了一发wa了，然后队友举出了反例，并发现最小值应该是sqrt(n)上取整,构造后过了</p>
<p>J 一眼线性回归最小二乘法，但是套了高中学的的求解公式wa了，原因是用化简后的公式求平均值时会造成精度损失，使用正常的公式可以直接将$\theta_1$和$\theta_0$求出可以通过</p>
<p>公式如下，添加进板子里了</p>
<script type="math/tex; mode=display">
\begin{align}
y = {\theta_0}x+{\theta_1}\\

\theta_1 = {\sum_{i = 1}^n{x_i}^2\sum_{i = 1}^ny_i-\sum_{i = 1}^nx_i\sum_{i = 1}^n{x_iy_i} \over n\sum_{i = 1}^nx_i^2 - (\sum_{i = 1}^nx_i)^2}\\

\theta_0 = {n\sum_{i = 1}^n{x_iy_i}-\sum_{i = 1}^n{x_i}\sum_{i = 1}^n{y_i} \over n\sum_{i = 1}^nx_i^2 - (\sum_{i = 1}^nx_i)^2}
\end{align}</script><p>K 队友切掉了，赛后补题感觉像cf原题</p>
<p>dp[i][j][k]表示对于新串的第 i 个字符，已经匹配了新串的j个字符，当前的新串左括号比右括号多的数量，然后分左右括号分类讨论一下每一位就可以了</p>
<p>E NTT不会，赛中推了个组合数的公式，但是始终过不了，原因不明</p>
<p>D 队友赛后几分钟过了，可惜。原因是double爆了，二分系数+spfa判负环，用long double 可以过</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>或许是因为网络赛的缘故，在家并没有比赛的氛围，有点像平时打cf，我并没有很紧张，同时英语阅读的问题导致我一度没有看懂题目，理解题意也消耗了很多时间，以后cf不能在用google翻译了QAQ，另外第二场补题时间不是很充裕，有题没来得及补，下周会抽时间补掉</p>
]]></content>
      <categories>
        <category>训练日志</category>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>训练日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 751 Div2</title>
    <url>/2021/10/25/CodeforcesRound751Div2/</url>
    <content><![CDATA[<p>蒟蒻过菜，只A了两题，在大佬的帮助下A掉C题。</p>
<h4 id="A-Two-Subsequences"><a href="#A-Two-Subsequences" class="headerlink" title="A Two Subsequences"></a>A Two Subsequences</h4><p>题意 ： 给定一个字符串s 将字符串拆成两个子串a,b a是字典序最小的子串 b和a能组成s。</p>
<p>思路：显然 a是个最小的字母 ， b是除了a之外的其他字符，扫一遍s找出a即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">char</span> minn = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt; minn)  &#123;</span><br><span class="line">                minn=s[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; minn &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == id)<span class="keyword">continue</span>;</span><br><span class="line">            cout &lt;&lt; s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>训练日志</category>
        <category>比赛日志</category>
      </categories>
      <tags>
        <tag>训练日志</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 4902 Nice boat线段树</title>
    <url>/2021/10/08/HDU-4902-Nice-boat%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://acm.dingbacode.com/showproblem.php?pid=4902">HDU - 4902</a></p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>对一段序列有两种操作 </p>
<ol>
<li>将区间全部赋成一个值</li>
<li>将区间中大于k的值变成该值与k的gcd</li>
</ol>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>显然这是线段树<br>我们维护一个懒标用来标记该区段是否被赋值，然后正常写线段树就好<br>可以维护一个max来剪枝（不写会出现奇怪的段错误，不明原因）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson x &lt;&lt; 1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson x &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">11</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,same,lazy,maxn;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> same(x) t[x].same</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lazy(x) t[x].lazy</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> maxn(x) t[x].maxn</span></span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b&gt;<span class="number">0</span> ? <span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">maxn</span>(x) = <span class="built_in">max</span>(<span class="built_in">maxn</span>(lson),<span class="built_in">maxn</span>(rson));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">same</span>(lson) == <span class="built_in">same</span>(rson))&#123;</span><br><span class="line">        <span class="built_in">same</span>(x) = <span class="built_in">same</span> (lson);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">same</span>(x) = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lazy</span>(x) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">maxn</span>(lson) = <span class="built_in">lazy</span>(x);</span><br><span class="line">        <span class="built_in">maxn</span>(rson) = <span class="built_in">lazy</span>(x);</span><br><span class="line">        <span class="built_in">same</span>(lson) = <span class="built_in">lazy</span>(x);</span><br><span class="line">        <span class="built_in">same</span>(rson) = <span class="built_in">lazy</span>(x);</span><br><span class="line">        <span class="built_in">lazy</span>(lson) = <span class="built_in">lazy</span>(x);</span><br><span class="line">        <span class="built_in">lazy</span>(rson) = <span class="built_in">lazy</span>(x);</span><br><span class="line">        <span class="built_in">lazy</span>(x) = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">l</span>(x) = l;</span><br><span class="line">    <span class="built_in">r</span>(x) = r;</span><br><span class="line">    <span class="built_in">lazy</span>(x) = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="built_in">same</span>(x) = a[l];</span><br><span class="line">        <span class="built_in">maxn</span>(x) = <span class="built_in">same</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lson,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rson,mid + <span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//if(l &gt;r(x)|| l(x) &gt;r)return;</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= <span class="built_in">l</span>(x) &amp;&amp; <span class="built_in">r</span>(x) &lt;= r)&#123;</span><br><span class="line">        <span class="built_in">same</span>(x) = k;</span><br><span class="line">        <span class="built_in">lazy</span>(x) = k;</span><br><span class="line">        <span class="built_in">maxn</span>(x) = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">l</span>(x) + <span class="built_in">r</span>(x)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">change1</span>(lson,l,r,k);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)&#123;</span><br><span class="line">        <span class="built_in">change1</span>(rson,l,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">maxn</span>(x) &lt;= k)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//if(l &gt;r(x)|| l(x) &gt;r)return;</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= <span class="built_in">l</span>(x) &amp;&amp; <span class="built_in">r</span>(x) &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">same</span>(x) != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//if(same(x) &gt; k)&#123;</span></span><br><span class="line">                <span class="built_in">same</span>(x) = <span class="built_in">gcd</span>(<span class="built_in">maxn</span>(x),k);</span><br><span class="line">                <span class="built_in">lazy</span>(x) = <span class="built_in">gcd</span>(<span class="built_in">maxn</span>(x),k);</span><br><span class="line">                <span class="built_in">maxn</span>(x) = <span class="built_in">gcd</span>(<span class="built_in">maxn</span>(x),k);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">l</span>(x) + <span class="built_in">r</span>(x)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">change2</span>(lson,l,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)&#123;</span><br><span class="line">        <span class="built_in">change2</span>(rson,l,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">l</span>(x) == <span class="built_in">r</span>(x))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maxn</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">l</span>(x) + <span class="built_in">r</span>(x)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(lson,pos);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(rson,pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> op,x,y,z;</span><br><span class="line">            cin &gt;&gt; op &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">change1</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">change2</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,i));</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>个人近几天写线段树易犯的错误：<br>将lson 写成 rson</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoderBeginnerContest235</title>
    <url>/2022/01/19/AtCoderBeginnerContest235/</url>
    <content><![CDATA[<h3 id="ABC235"><a href="#ABC235" class="headerlink" title="ABC235"></a><a href="https://atcoder.jp/contests/abc235">ABC235</a></h3><h4 id="T1-Rotate"><a href="#T1-Rotate" class="headerlink" title="T1 Rotate"></a>T1 <a href="https://atcoder.jp/contests/abc235/tasks/abc235_a">Rotate</a></h4><p><strong>题意</strong></p>
<p>给定一个三位数abc</p>
<p>求 abc + bca + cab 的和</p>
<p><strong>解题过程</strong></p>
<p>暴力求和即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a = n % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = n / <span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> c = n / <span class="number">100</span>;</span><br><span class="line">    sum += a * <span class="number">100</span> + b * <span class="number">10</span> + c;</span><br><span class="line">    sum += b * <span class="number">100</span> + c * <span class="number">10</span> + a;</span><br><span class="line">    sum += c * <span class="number">100</span> + a * <span class="number">10</span> + b;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T2-Climbing-Takahashi"><a href="#T2-Climbing-Takahashi" class="headerlink" title="T2 Climbing Takahashi"></a>T2 <a href="https://atcoder.jp/contests/abc235/tasks/abc235_b">Climbing Takahashi</a></h4><p><strong>题意</strong></p>
<p>一个人站在最左侧向，仅向相邻右侧更高处移动，问最终位置</p>
<p><strong>解题过程</strong></p>
<p>从左向右枚举，直到a[i + 1] &lt;= a[i],此时的i即为答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100111</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; a[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; a[i<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">            f = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f == <span class="number">0</span>)cout &lt;&lt; a[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T3-The-Kth-Time-Query"><a href="#T3-The-Kth-Time-Query" class="headerlink" title="T3 The Kth Time Query"></a>T3 <a href="https://atcoder.jp/contests/abc235/tasks/abc235_c">The Kth Time Query</a></h4><p><strong>题意</strong></p>
<p>给定一个数组A 含有n个元素  <em>A</em> =(<em>a</em>1,<em>a</em>2,…,<em>a**N</em>) ，Q组询问 (x<em>i,<em>k</em>i</em>)  即第k个x出现的位置</p>
<p><strong>解题过程</strong></p>
<p>map大法好，直接用map&lt;pair&lt;int,int&gt;,int&gt;mp;预处理出每种元素的出现位置，然后询问时直接查询。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;vis;</span><br><span class="line">map&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        x = <span class="built_in">read</span>();</span><br><span class="line">        vis[x]++;</span><br><span class="line">        mp[<span class="built_in">make_pair</span>(x,vis[x])] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,k;</span><br><span class="line">        x = <span class="built_in">read</span>(); k = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">find</span>(<span class="built_in">make_pair</span>(x,k)) != mp.<span class="built_in">end</span>())</span><br><span class="line">            cout &lt;&lt; mp[<span class="built_in">make_pair</span>(x,k)] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="T4-Multiply-and-Rotate"><a href="#T4-Multiply-and-Rotate" class="headerlink" title="T4 Multiply and Rotate"></a>T4 <a href="https://atcoder.jp/contests/abc235/tasks/abc235_d">Multiply and Rotate</a></h4><p>卡题了，WA了两天不明白思路有什么问题QAQ</p>
<p><strong>题意</strong></p>
<p>给定 <em>a</em> ,<em>N</em>  数字<em>x</em> 为1,对<em>x</em>有两种操作</p>
<p>操作1：x = x * a</p>
<p>操作2：将x的最右位变成最左位 如123 变成 312</p>
<p>问将<em>x</em>变为<em>N</em>的最小步数</p>
<p><strong>解题过程</strong></p>
<p>map大法好，直接用map&lt;pair&lt;int,int&gt;,int&gt;mp;预处理出每种元素的出现位置，然后询问时直接查询。</p>
<p>可以看出搜索可以解决问题，先写了dfs但是感觉复杂度过不过去，</p>
<p>可以考虑两个优化操作</p>
<p>如果使用bfs对于已经得到结果可以终止搜索，先得到的结果必定是最优解，并且对于已经搜索过的值可以不用重复搜索。</p>
<p>我本来想的是倒着从N开始搜索到1 (<del>WA了两天，始终有2个点过不去</del>)</p>
<p>后来考虑到有这样一种情况 </p>
<blockquote>
<p>5 25 52 260 26 62 310</p>
</blockquote>
<p>如果一个数字末尾是0 那么把0放在开头相当于 x/=10.如果倒着搜索的话需要对每个值都*10再判断，计算量明显高于正向搜索</p>
<p>所以从1向N搜索，以题意模拟即可AC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">#define int long long</span><br><span class="line">map&lt;int,int&gt;mp;</span><br><span class="line">map&lt;int,int&gt;vis;</span><br><span class="line">int a,n;</span><br><span class="line">int pw[20];</span><br><span class="line">int ans = 1e9;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    a = read(); n = read();</span><br><span class="line">    pw[0] = 1;</span><br><span class="line">    pw[1] = 10;</span><br><span class="line">    for(int i = 2; i &lt; 20; i++)&#123;</span><br><span class="line">        pw[i] = pw[i-1] * 10;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    q.push(1);</span><br><span class="line">    vis[1] = 1;</span><br><span class="line">    mp[1] = 0;</span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        int x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(x == n)&#123;</span><br><span class="line">            ans = min(mp[x],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        if(x * a &lt;= 1e6 + 5)&#123;</span><br><span class="line">            if(vis.find(x * a) == vis.end())&#123;</span><br><span class="line">                //cout &lt;&lt; x &lt;&lt; &quot; &quot;&lt;&lt; mp[x] &lt;&lt; &quot; &quot; &lt;&lt; x/a &lt;&lt; &quot; &quot; &lt;&lt; mp[x/a] &lt;&lt; endl;</span><br><span class="line">                vis[x * a] = 1;</span><br><span class="line">                mp[x * a] = mp[x] + 1; </span><br><span class="line">                q.push(x * a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x % 10 != 0 &amp;&amp; x &gt;= 10)&#123;</span><br><span class="line">            int len = log10(x);</span><br><span class="line">            int y = x / 10 + x % 10 * pw[len];</span><br><span class="line">            if(vis.find(y) == vis.end())&#123;</span><br><span class="line">                mp[y] = mp[x] + 1;</span><br><span class="line">                vis[y] = 1;</span><br><span class="line">                //cout &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; mp[y] &lt;&lt; endl;</span><br><span class="line">                q.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans != 1e9)</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    else cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T5-MST-1"><a href="#T5-MST-1" class="headerlink" title="T5 MST + 1"></a>T5 <a href="https://atcoder.jp/contests/abc235/tasks/abc235_e">MST + 1</a></h4><p><strong>题意</strong></p>
<p>给定一个<em>n</em>个节点<em>m</em>条边的无向图，<em>Q</em>次询问。每次询问给定一条新边，问如果原图加入新边，最小生成树是否包括新边。</p>
<p><strong>解题过程</strong></p>
<p>Ashen教了种很简单的做法，就是离线把所有边(包括新边)构建最小生成树，然后对于新加入的边只标记，不连接，这样构建最小生成树的同时能标记下比原图更优的边</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000020</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w,id;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N],v[N],id[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] != x)&#123;</span><br><span class="line">        <span class="keyword">return</span> f[x] = <span class="built_in">F</span>(f[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q;</span><br><span class="line">    n = <span class="built_in">read</span>();m = <span class="built_in">read</span>();q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        a[i].u = <span class="built_in">read</span>(); a[i].v = <span class="built_in">read</span>();</span><br><span class="line">        a[i].w = <span class="built_in">read</span>();</span><br><span class="line">        id[i] = i;</span><br><span class="line">        a[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        a[i + m].u = <span class="built_in">read</span>(); a[i + m].v = <span class="built_in">read</span>();</span><br><span class="line">        a[i + m].w = <span class="built_in">read</span>();</span><br><span class="line">        a[i + m].id = i + m;</span><br><span class="line">        id[i + m] = i + m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m + q, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[i].u;</span><br><span class="line">        <span class="keyword">int</span> y = a[i].v;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">F</span>(x) != <span class="built_in">F</span>(y))&#123;</span><br><span class="line">            v[a[i].id] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i].id &gt; m)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[<span class="built_in">F</span>(x)] = <span class="built_in">F</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[id[i + m]] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然遇到最小生成树了不妨开个专题</p>
<p>未完待续QwQ</p>
]]></content>
      <categories>
        <category>训练日志</category>
        <category>比赛日志</category>
      </categories>
      <tags>
        <tag>训练日志</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-1679 The Unique MST</title>
    <url>/2022/01/21/POJ-1679-TheUniqueMST/</url>
    <content><![CDATA[<h4 id="判断最小生成树路径唯一"><a href="#判断最小生成树路径唯一" class="headerlink" title="判断最小生成树路径唯一"></a>判断最小生成树路径唯一</h4><h4 id="POJ-1679-The-Unique-MST-poj-org"><a href="#POJ-1679-The-Unique-MST-poj-org" class="headerlink" title="POJ-1679 The Unique MST (poj.org)"></a><a href="http://poj.org/problem?id=1679">POJ-1679 The Unique MST (poj.org)</a></h4><p><strong>思路</strong></p>
<p>kruskal先跑一遍记录路径 然后依次删掉每条边判断新最小生成树与远最小生成树是否相等</p>
<p>复杂度<em>O(nmlogm)</em> ,待学习新方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//最小生成树是否唯一</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,num,t,sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">F</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">100001</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            a[i].u = <span class="built_in">read</span>();</span><br><span class="line">            a[i].v = <span class="built_in">read</span>();</span><br><span class="line">            a[i].w = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m, cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">F</span>(a[i].u);</span><br><span class="line">            <span class="keyword">int</span> y = <span class="built_in">F</span>(a[i].v);</span><br><span class="line">            <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">                f[x] = y;</span><br><span class="line">                vis[++num] = i;</span><br><span class="line">                sum += a[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++)&#123;</span><br><span class="line">            <span class="built_in">init</span>(n);</span><br><span class="line">            <span class="keyword">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == vis[i])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="built_in">F</span>(a[j].u);</span><br><span class="line">                <span class="keyword">int</span> y = <span class="built_in">F</span>(a[j].v);</span><br><span class="line">                <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">                    f[x] = y;</span><br><span class="line">                    sum2 += a[j].w;</span><br><span class="line">                    num2 ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(num2 != num)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(sum2 == sum)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Not Unique!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>学到一种新方法</strong></p>
<p>考虑最小生成树的唯一性。如果一条边 <strong>不在最小生成树的边集中</strong>，并且可以替换与其 <strong>权值相同、并且在最小生成树边集</strong> 的另一条边。那么，这个最小生成树就是不唯一的。</p>
<p>证明方法kruskal</p>
<p>对于已连接的边集<em>E</em> ,考虑下一条加入的边<em>v</em>,若存在另一条边<em>v1</em>，v1 &gt; v || v1 &lt; v时，v1都不可能是下一条加入的边。</p>
<p>所以只需要考虑当前边长度相同的边即可</p>
<p>由于使用了单调队列所以复杂度和kruskal相同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100001</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;;</span><br><span class="line">node a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">F</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            a[i].u = <span class="built_in">read</span>();</span><br><span class="line">            a[i].v = <span class="built_in">read</span>();</span><br><span class="line">            a[i].w = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m, cmp);</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>, num = <span class="number">0</span>, flag = <span class="number">0</span>,tail = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; tail)&#123;<span class="comment">//tail记录最后长度相同的边的指针</span></span><br><span class="line">                <span class="comment">//sum2记录可以合并的长度相同的边数</span></span><br><span class="line">                <span class="comment">//sum1记录实际最小生成树中连接的边数</span></span><br><span class="line">                <span class="comment">//如果两个不相等说明有可以替换的边，则最小生成树不唯一</span></span><br><span class="line">                <span class="keyword">if</span>(sum1 != sum2)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum1 = <span class="number">0</span>;</span><br><span class="line">                sum2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= m + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j].w != a[i].w)&#123;</span><br><span class="line">                        tail = j - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">F</span>(a[j].u) != <span class="built_in">F</span>(a[j].v))&#123;</span><br><span class="line">                        sum2++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; m)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">F</span>(a[i].u);</span><br><span class="line">            <span class="keyword">int</span> y = <span class="built_in">F</span>(a[i].v);</span><br><span class="line">            <span class="keyword">if</span>(x != y &amp;&amp; num != n<span class="number">-1</span>)&#123;</span><br><span class="line">                f[x] = y;</span><br><span class="line">                num ++;</span><br><span class="line">                sum1++;</span><br><span class="line">                ans += a[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Not Unique!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing - 348 走廊泼水节</title>
    <url>/2021/10/18/acwing-348-%E8%B5%B0%E5%BB%8A%E6%B3%BC%E6%B0%B4%E8%8A%82/</url>
    <content><![CDATA[<p><a href="https://www.acwing.com/problem/content/348/">链接</a></p>
<h5 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h5><p>给定一棵 N 个节点的树，要求增加若干条边，把这棵树扩充为完全图，并满足图的唯一最小生成树仍然是这棵树。求增加的边的权值总和最小是多少。</p>
<h5 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h5><p>完全图</p>
<p>在图论的数学领域，完全图是一个<strong>简单的无向图</strong>，其中每对不同的顶点之间都恰连有一条边相连。</p>
<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>根据Kruskal算法的原理，任何一棵最小生成树一定包含无向图中权值最小的边。所以要保证当前的树是补充完后的完全图的最小生成树，我们每次在两个并查集之间加的边都要比当前边要大1， 我们要增加的边数等于两个并查集的节点数的乘积-1，通过Kruskal算法遍历原图生成最小生成树时添加边即可ac</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>s表示并查集中的节点数</p>
<p>f表示父亲节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;a[<span class="number">6011</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">6011</span>],s[<span class="number">6011</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.z &lt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> f[x] = <span class="built_in">F</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">            s[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n, cmp);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="built_in">F</span>(a[i].x);</span><br><span class="line">            <span class="keyword">int</span> v = <span class="built_in">F</span>(a[i].y);</span><br><span class="line">            <span class="keyword">int</span> w = a[i].z;</span><br><span class="line">            <span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">                f[u] = v;</span><br><span class="line">                ans += (s[v] * s[u] - <span class="number">1</span>) * (w + <span class="number">1</span>);</span><br><span class="line">                s[v] += s[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>dp problem</title>
    <url>/2022/03/28/dp-problem/</url>
    <content><![CDATA[<h2 id="dp-problem-wwwttlll"><a href="#dp-problem-wwwttlll" class="headerlink" title="dp problem | wwwttlll"></a><a href="https://wwwttlll.github.io/2022/03/28/dp-problem/#more">dp problem | wwwttlll</a></h2><h2 id="网页版阅读体验更佳哦"><a href="#网页版阅读体验更佳哦" class="headerlink" title="网页版阅读体验更佳哦"></a>网页版阅读体验更佳哦</h2><h3 id="Diluc-and-Kaeya"><a href="#Diluc-and-Kaeya" class="headerlink" title="Diluc and Kaeya"></a>Diluc and Kaeya</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个字符串 <em>S</em>，其中只包含 ‘<em>K</em>‘ 或 ‘<em>D</em>‘ 两种字符，要求划分这个字符串使得各部分的n*(<em>D</em>):<em>n</em>(<em>K</em>) 相同，其中 <strong>n(D)</strong> 表示 <strong>S</strong> 中字符 ‘D’ 出现的个数，最大化划分后形成的组数。求出 <em>S</em> 的所有前缀中的上述答案。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果当前字符串可以拆成若干个子串 <em>K:D</em>比例相同，那么每一个子串的比例和当前字符串K:D的比例一定相同</p>
<p>所以只要记录一下当前字符串比例是否出现过即可，若当前比例没有出现，则当前串不可拆分，否则，当前字符串可以拆分成比例出现的次数</p>
<p>cnt1 表示当前前缀中K的个数，cnt2表示当前前缀中D的个数</p>
<blockquote>
<p>K : D = cnt1/GCD(cnt1,cnt2) : cnt2/GCD(cnt1,cnt2) </p>
</blockquote>
<p>//gcd是最大公因数</p>
<p>然后开个map记录一下当前比例出现次数，就做完了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int gcd(int x ,int y)&#123;</span></span><br><span class="line"><span class="comment">    while(y ^= x ^= y ^= x %= y);</span></span><br><span class="line"><span class="comment">    return x;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>();cout.<span class="built_in">tie</span>();</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">        map&lt;pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; ,<span class="keyword">int</span> &gt;mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;K&#x27;</span>)cnt1++;</span><br><span class="line">            <span class="keyword">else</span> cnt2++;</span><br><span class="line">            <span class="keyword">int</span> g = <span class="built_in">gcd</span>(cnt1,cnt2);</span><br><span class="line">            mp[<span class="built_in">make_pair</span>(cnt1/g,cnt2/g)]++;</span><br><span class="line">            cout &lt;&lt; mp[<span class="built_in">make_pair</span>(cnt1/g,cnt2/g)] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="The-Sports-Festival"><a href="#The-Sports-Festival" class="headerlink" title="The Sports Festival"></a>The Sports Festival</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定长度为 <em>n</em>的序列 <em>s</em>，你可以改变序列 <em>s</em> 的顺序,求重排后，**$$\sum_1^n\max_{1…i} - \min_{1…i}$$**的最小值</p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>设a[i]表示重排后s的第i位，d[i] 表示 a[i] - a[i - 1] </p>
<p>可以发现不管s的顺序如何，d[n]一定是全局的max - min</p>
<p>如果整体的最大值和最小值排在第一位和第二位，那么d[i]都等于max- min,这显然是最差的情况</p>
<p>我们要求得到是d的和最小，所以应该尽可能把较大的值或较小的值往后放，使最大值最小值对结果的贡献尽可能小。</p>
<p>不妨将s排序</p>
<p>所以最后一位是s[1]或s[n]</p>
<p>然后从后向前推那么d[n - 1]的最优解要么是a[n]-a[2]（将第一位放在最后）要么是a[n-1]-a[1]（将第n位放在最后）</p>
<p>依次类推，可得状态转移方程</p>
<p>dp [i] [j] 表示<br>$$<br>\min\sum_i^j(\max_{1…i} - \min_{1…i})<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = min(dp[i+1][j],d[i][j-1])+a[j]-a[i]</span><br></pre></td></tr></table></figure>

<p>赤裸裸的区间dp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">#define ll long long</span><br><span class="line">int n;</span><br><span class="line">const int N = 2011;</span><br><span class="line">ll ans = 1e10 + 7;</span><br><span class="line">ll a[N],f[N][N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    memset(f,0x3f,sizeof f);</span><br><span class="line">    for(int i = 1 ; i &lt;= n; i++)&#123;</span><br><span class="line">        a[i] = read();</span><br><span class="line">        f[i][i]=0;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + 1, a + 1 + n);</span><br><span class="line">    for(int len = 2 ; len &lt;= n; len++)&#123;</span><br><span class="line">        for(int i = 1 ; i + len - 1 &lt;= n; i++)&#123;</span><br><span class="line">            int j = i + len - 1;</span><br><span class="line">            f[i][j] = min(f[i + 1][j], f[i][j - 1]) + a[j] - a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[1][n] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Say-No-to-Palindromes"><a href="#Say-No-to-Palindromes" class="headerlink" title="Say No to Palindromes"></a><a href="https://codeforces.com/contest/1555/problem/D">Say No to Palindromes</a></h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个字符串s长度为n，字符串中只含有a,b,c, 你可以将任意字符改为a,b,c,询问m次，每次给出l，r,即截取字符串中s[l]到s[r]这一段子串，询问最少修改几次使该段子串不包含长度至少为2的回文子串。</p>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>因为要求不含有长度大于2的回文子串，所以根据定义，字符串中相邻字符不能相同 (不能有aa类型的)，相隔一项的字符不能相同（不能有aba类型的)，经过手玩小数据后可得，修改完成的字符串必然是abcabcabc…这样的循环串。</p>
<p>满足条件的循环串就是abc的全排列的循环</p>
<blockquote>
<p>“abc”,”acb”,”bac”,”bca”,”cab”,”cba”</p>
</blockquote>
<p>然后可以预处理出来整个字符串每一位改成6种循环串需要修改的次数。</p>
<p>然后用前缀和的思想用字符串从s[0]到s[r]的修改次数- s[0] 到 s[l-1]的修改次数，可得l到r的修改次数</p>
<p>最后六种情况取min即可</p>
<p>这题不太像dp，应该是类似构造的题，然后用前缀和处理QAQ</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">11</span>;</span><br><span class="line">string s;</span><br><span class="line">string temp[<span class="number">6</span>] = &#123;<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;acb&quot;</span>,<span class="string">&quot;bac&quot;</span>,<span class="string">&quot;bca&quot;</span>,<span class="string">&quot;cab&quot;</span>,<span class="string">&quot;cba&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            f[j][i] = f[j - <span class="number">1</span>][i] + (s[j<span class="number">-1</span>] == temp[i][(j<span class="number">-1</span>) % <span class="number">3</span>] ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1e6</span> + <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)&#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans , f[r][j] - f[l - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Increase-Subarray-Sums"><a href="#Increase-Subarray-Sums" class="headerlink" title="Increase Subarray Sums"></a><a href="https://codeforces.com/contest/1644/problem/C">Increase Subarray Sums</a></h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>题意：给定长度为n(1&lt;=n&lt;=5000)的数组a和数x</p>
<p>$-10^5 &lt;=i &lt;= 10^5 $</p>
<p>现在定义f(k)表示从数组a中选取k个不同的元素，分别加上x后，能得到的最大连续子区间和。<br>求f ( k ) , 0 &lt; = k &lt; = n f(k),0&lt;=k&lt;=nf(k),0&lt;=k&lt;=n</p>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>定义**<em>f</em> *[<em>j</em>][<em>i</em>]<em><strong>表示到第 <strong>j</strong> 位,已经给 <strong>i</strong> 个元素增加了</strong>k</em>* 的最大子段和</p>
<p>显然当j=0时就是求数组的最大子段和，所以可以预处理j=0的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f[j][0] = max(f[j - 1][0] + a[j], a[j]);</span><br></pre></td></tr></table></figure>

<p>然后考虑j&gt;0的转移</p>
<p>每到一位a[i]当前位置可以增加k，也可以不增加</p>
<p>为了避免多次遍历中，重复为一位增加k，我们可以从上一位更新当前位的状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sta1 = max(f[j - 1][i] , (ll)0) + a[j];</span><br><span class="line">sta2 = max(f[j - 1][i - 1] , (ll)0)  + a[j] + k;</span><br></pre></td></tr></table></figure>

<p>然后两种状态取max即可得到当前**<em>f</em> *[<em>j</em>][<em>i</em>]***的状态</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5111</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, k;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line">ll f[N][N]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        n = <span class="built_in">read</span>(); k = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            a[i] = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//memset(f,0,sizeof f);</span></span><br><span class="line">        ll maxn = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>] + a[i], <span class="number">1ll</span> * a[i]);</span><br><span class="line">            maxn = <span class="built_in">max</span>(f[i][<span class="number">0</span>],maxn);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; maxn &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;<span class="comment">//加i次</span></span><br><span class="line">            maxn = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;<span class="comment">//第j位</span></span><br><span class="line">                ll sta1 = <span class="built_in">max</span>(f[j - <span class="number">1</span>][i] , (ll)<span class="number">0</span>) + a[j];</span><br><span class="line">                ll sta2 = <span class="built_in">max</span>(f[j - <span class="number">1</span>][i - <span class="number">1</span>] , (ll)<span class="number">0</span>)  + a[j] + k;</span><br><span class="line">                f[j][i] = <span class="built_in">max</span>(sta1,sta2);</span><br><span class="line">                maxn = <span class="built_in">max</span>(maxn,f[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; maxn &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Just-Eat-It"><a href="#Just-Eat-It" class="headerlink" title="Just Eat It!"></a><a href="https://codeforces.com/contest/1285/problem/B">Just Eat It!</a></h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定长度为 <em>n</em> 的数列 $a=[a_1,a_2,…,a_n]$。</p>
<p>Yasser 会选择所有的 <em>n</em> 个数，并算出它们的和 $\sum a_i$</p>
<p>Adel 会选择两个正整数 l,r($1\leq l \leq r \leq n)$，并算出 $\sum_{i=l}^{r} a_i$。Adel 不能选择$ l=1,r=n$。</p>
<p>如果 Yasser 算出的和在任意情况下（即 Adel 选取任意的<em>l</em>,<em>r</em> 都是如此）<strong>严格大于</strong> Adel 算出的，那么 Yasser 会开心。否则 Yasser 不会开心。</p>
<p>请你判断 Yasser 是否开心。</p>
<h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>和上题类似，这题要求求出最大子段和和全部和比较</p>
<p>和上题i= 0的情况相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f[j] = max(f[j - 1] + a[j], a[j]);</span><br></pre></td></tr></table></figure>

<p>然后由于Adel 不能选择$ l=1,r=n$，所以需要额外记录一下子段的起点，使得$ l\neq1,r\neq n$，即总长度不等于n。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">const int N = 1e5 + 11;</span><br><span class="line">int n,t;</span><br><span class="line">int a[N];</span><br><span class="line">long long f[N];</span><br><span class="line">int head[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    t = read();</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        n = read();</span><br><span class="line">        long long sum = 0;</span><br><span class="line">        memset(f,0,sizeof f);</span><br><span class="line">        memset(head,0,sizeof head);</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            a[i] = read();</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        head[1] = 1;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            if(f[i - 1] &lt;= 0)&#123;</span><br><span class="line">                f[i] = a[i];</span><br><span class="line">                head[i] = i;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                f[i] = f[i - 1] + a[i];</span><br><span class="line">                head[i] = head[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">            if(sum &lt;= f[i] &amp;&amp; i - head[i] + 1 &lt; n)flag = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag == 1)puts(&quot;NO&quot;);</span><br><span class="line">        else puts(&quot;YES&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Constanze’s-Machine"><a href="#Constanze’s-Machine" class="headerlink" title="Constanze’s Machine"></a><a href="https://codeforces.com/problemset/problem/1245/C">Constanze’s Machine</a></h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>有原字符串s,经过转换得到ss,转换的方式为把s中的字符‘w’和‘m’分别转换成‘uu’和‘nn’</p>
<p>现在知道ss求有多少种可能的s ，答案对1e9+7取模</p>
<h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>经过简单的手玩</p>
<p>n-&gt;1</p>
<p>nn-&gt;2</p>
<p>nnn-&gt;3</p>
<p>nnnn-&gt;5</p>
<p>nnnnn-&gt;8</p>
<p>可以发现连续k的u或n对应的可能的原字符串数是一个斐波那契数列的第n项（第二项是2）</p>
<p>所以预处理斐波那契数列，然后遍历字符串分别求出每一段的连续u和连续n的个数，然后应用乘法原理得到答案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">#define endl &#x27;\n&#x27;</span><br><span class="line">long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">const int p = 1e9 + 7;</span><br><span class="line">const int MAXN = 1e5 + 11;</span><br><span class="line">ll f[MAXN];</span><br><span class="line">int main()&#123;</span><br><span class="line">	ios::sync_with_stdio(0);</span><br><span class="line">    cin.tie();cout.tie();</span><br><span class="line">    f[1] = 1;f[2] = 2;</span><br><span class="line">    for(int i = 3; i &lt;= MAXN; i++)&#123;</span><br><span class="line">        f[i] = (f[i - 1] + f[i - 2]) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    int cnt1 = 0, cnt2 = 0;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    for(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">        if(s[i] == &#x27;w&#x27; || s[i] == &#x27;m&#x27;) &#123;</span><br><span class="line">            puts(&quot;0&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i] == &#x27;u&#x27;)cnt1++;</span><br><span class="line">        if(s[i] == &#x27;n&#x27;)cnt2++;</span><br><span class="line">        if(s[i + 1] != &#x27;u&#x27; &amp;&amp; cnt1)&#123;</span><br><span class="line">            ans = ans * f[cnt1] % p;</span><br><span class="line">            cnt1 = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i + 1] != &#x27;n&#x27; &amp;&amp; cnt2)&#123;</span><br><span class="line">            ans = ans * f[cnt2] % p;</span><br><span class="line">            cnt2 = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//u 1</span><br><span class="line">//uu 2</span><br><span class="line">//uuu 3</span><br><span class="line">//uuuu 5</span><br><span class="line">//uuuuu 8</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu - 1886 滑动窗口</title>
    <url>/2021/10/05/luogu-1886-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1886">滑动窗口</a><br>head tail维护单调队列中的队首和队尾 发现新元素<br>枚举i来遍历整个数列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> qx[N],qn[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmax</span><span class="params">()</span></span>&#123;<span class="comment">//求最大值,保持队列单减,保证队首最大</span></span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>,tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head &lt;= tail &amp;&amp; a[qx[tail]] &lt;= a[i])   tail--;</span><br><span class="line">        <span class="comment">//找到前k个数中的最值 一旦遇到了破环队列单调性的值 就清空数列</span></span><br><span class="line">        <span class="comment">//遇到大的就不符合</span></span><br><span class="line">        qx[++tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i++)&#123;<span class="comment">//同理</span></span><br><span class="line">        <span class="keyword">while</span>(head &lt;= tail &amp;&amp; a[qx[tail]] &lt;= a[i])   tail--;</span><br><span class="line">        qx[++tail] = i;</span><br><span class="line">        <span class="keyword">while</span>(qx[head] &lt;= (i - k))&#123;<span class="comment">//因为题目中限制区间长度为k,队首位置超出区间也要出队</span></span><br><span class="line">            head ++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; a[qx[head]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>,tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head &lt;= tail &amp;&amp; a[qn[tail]] &gt;= a[i])   tail--;</span><br><span class="line">        qn[++tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head &lt;= tail &amp;&amp; a[qx[tail]] &gt;= a[i])   tail--;</span><br><span class="line">        qn[++tail] = i;</span><br><span class="line">        <span class="keyword">while</span>(qn[head] &lt;= (i - k))&#123;</span><br><span class="line">            head ++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; a[qn[head]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getmin</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">getmax</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy学习</title>
    <url>/2022/07/02/numpy%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="numpy学习"><a href="#numpy学习" class="headerlink" title="numpy学习"></a>numpy学习</h3><p>官方文档<a href="https://numpy.org/devdocs/user/index.html">https://numpy.org/devdocs/user/index.html</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>

<h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">b = [i ** <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    a[i] = a[i] + b[i]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#arange</span></span><br><span class="line"><span class="comment">#numpy.arange(start, stop, step, dtype)</span></span><br><span class="line">a = np.arange(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a = np.arange(<span class="number">1</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<pre><code>[0 1 2 3 4 5]
[1 2 3 4 5]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">list2 = <span class="built_in">list</span></span><br><span class="line">list2[<span class="number">3</span>] = <span class="built_in">list</span>[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">list</span></span><br><span class="line"><span class="comment">#引用传值</span></span><br></pre></td></tr></table></figure>




<pre><code>[1, 2, 3, 2]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="built_in">list</span>[<span class="number">0</span>]</span><br><span class="line">c = <span class="number">10</span></span><br><span class="line"><span class="built_in">list</span></span><br></pre></td></tr></table></figure>




<pre><code>[1, 10, 3, 4]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">b = np.array(a)</span><br><span class="line">c = a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a:&quot;</span>,<span class="built_in">id</span>(a), <span class="string">&quot;b:&quot;</span>, <span class="built_in">id</span>(b), <span class="string">&quot;c:&quot;</span>, <span class="built_in">id</span>(c))</span><br><span class="line"><span class="comment">#修改c a也会改变</span></span><br><span class="line"><span class="comment">#修改b a不会改变</span></span><br></pre></td></tr></table></figure>

<pre><code>a: 2332076015904 b: 2331640327744 c: 2332076015904
[2 4 5]
[3 4 5]
[[2 3]
 [4 5]
 [5 6]]
</code></pre>
<p>当a，b是可变对象时，b和a指向同一个内存空间，改变a中的值（a的内存空间地址不变），则b跟着改变（b的内存空间地址不变）;同样的，改变b中的值，则a跟着改变。</p>
<p>当a，b是不可变对象时，b和a指向同一个内存空间，改变a中的值（a的内存空间地址改变），这时b不跟着改变（因为b的内存空间地址不变）;同样的，改变b中的值，这时a不跟着改变。</p>
<p>可变对象：list dict set<br>不可变对象：tuple string int float bool</p>
<h5 id="生成数组"><a href="#生成数组" class="headerlink" title="生成数组"></a>生成数组</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#linspace 等差数列</span></span><br><span class="line"><span class="comment">#np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</span></span><br><span class="line"><span class="comment">#endpoint	该值为 true 时，数列中包含stop值，反之不包含，默认是True。</span></span><br><span class="line"><span class="comment">#retstep	如果为 True 时，生成的数组中会显示公差，反之不显示。</span></span><br><span class="line">b = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>,retstep = <span class="literal">True</span>, dtype = <span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment">#logspace 等比 base^(start) ~ base^(stop)</span></span><br><span class="line"><span class="comment">#np.logspace(start , stop, num=50, endpoint=True, base=10.0, dtype=None) </span></span><br><span class="line">c = np.logspace(<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,base = <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">x = np.zeros((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">x = np.ones((<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>

<pre><code>(array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10]), 1.0)
[ 2.  8. 32.]
[[0. 0.]
 [0. 0.]]
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
</code></pre>
<h4 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="built_in">print</span> (a[...,<span class="number">1</span>])   <span class="comment"># 第2列元素</span></span><br><span class="line"><span class="built_in">print</span> (a[<span class="number">1</span>,...])   <span class="comment"># 第2行元素</span></span><br><span class="line"><span class="built_in">print</span> (a[...,<span class="number">1</span>:])  <span class="comment"># 第2列及剩下的所有元素</span></span><br></pre></td></tr></table></figure>

<pre><code>[2 4 5]
[3 4 5]
[[2 3]
 [4 5]
 [5 6]]
y:[3 5 7]





array([[1, 3],
       [7, 9]])
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#高级索引</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">y = x[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>] ]<span class="comment">#0,2 1,1 2,0 的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;y:<span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">rows = np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">2</span>]]) </span><br><span class="line">cols = np.array([[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]]) </span><br><span class="line">z = x[rows,cols]</span><br><span class="line"><span class="built_in">print</span>(z)<span class="comment">#高级索引</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">y = x[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>] ]<span class="comment">#0,2 1,1 2,0 的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;y:<span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">rows = np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">2</span>]]) </span><br><span class="line">cols = np.array([[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]]) </span><br><span class="line">z = x[rows,cols]</span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure>

<pre><code>y:[3 5 7]
[[1 3]
 [7 9]]
y:[3 5 7]
[[1 3]
 [7 9]]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#布尔索引</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(x[x &gt; <span class="number">4</span>])</span><br><span class="line">np.nan <span class="comment">#numpy pandas 表示空缺数据</span></span><br><span class="line">x = np.array([np.nan,<span class="number">1</span>,np.nan, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(np.isnan(x))</span><br><span class="line"><span class="built_in">print</span>(x[~np.isnan(x)])</span><br><span class="line"><span class="comment">#多条件bool索引</span></span><br><span class="line">x[np.logical_and(x &gt; <span class="number">2</span> , x &lt; <span class="number">5</span>)]</span><br><span class="line">x[(x &gt; <span class="number">2</span>) &amp; (x &lt; <span class="number">5</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>[5 6]
[ True False  True False False]
[1. 3. 4.]





array([3., 4.])
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">32</span>).reshape(<span class="number">8</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#a[np.ix_([1,3],[2,5])] returns the array [[a[1,2] a[1,5]], [a[3,2] a[3,5]]].</span></span><br><span class="line">a[np.ix_([<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="number">0</span>,<span class="number">2</span>])]</span><br></pre></td></tr></table></figure>

<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]
 [16 17 18 19]
 [20 21 22 23]
 [24 25 26 27]
 [28 29 30 31]]



array([[ 4,  6],
       [20, 22],
       [28, 30]])
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#lambda 简化函数</span></span><br><span class="line">fun = <span class="keyword">lambda</span> x : x + <span class="number">1</span></span><br><span class="line">funcb = <span class="keyword">lambda</span> x:x+<span class="number">1</span> <span class="keyword">if</span> x==<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">funcc = [<span class="keyword">lambda</span> x: x+j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">[f(<span class="number">1</span>) <span class="keyword">for</span> f <span class="keyword">in</span> funcc]</span><br><span class="line"><span class="comment">#迷惑</span></span><br></pre></td></tr></table></figure>




<pre><code>[5, 5, 5, 5, 5]
</code></pre>
<h4 id="迭代和修改数组"><a href="#迭代和修改数组" class="headerlink" title="迭代和修改数组"></a>迭代和修改数组</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#遍历</span></span><br><span class="line">a = np.arange(<span class="number">16</span>).reshape(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a):</span><br><span class="line">    <span class="built_in">print</span>(x,end = <span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a.T):</span><br><span class="line">    <span class="built_in">print</span>(x, end = <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a.T.copy(order= <span class="string">&#x27;C&#x27;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(x, end = <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a.copy(order= <span class="string">&#x27;F&#x27;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(x, end = <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a,order= <span class="string">&#x27;F&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, end = <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a,order= <span class="string">&#x27;C&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, end = <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="comment">#修改</span></span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) </span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, op_flags=[<span class="string">&#x27;readwrite&#x27;</span>]): </span><br><span class="line">    x[...] = <span class="number">2</span>*x <span class="comment">#x[...] 是修改原 numpy 元素，x 只是个拷贝。</span></span><br><span class="line">a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
0,2,4,6,8,10,12,14,1,3,5,7,9,11,13,15,
0,2,4,6,8,10,12,14,1,3,5,7,9,11,13,15,
0,2,4,6,8,10,12,14,1,3,5,7,9,11,13,15,
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,





array([[  0,  10,  20,  30],
       [ 40,  50,  60,  70],
       [ 80,  90, 100, 110]])
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#transpose 转置</span></span><br><span class="line">a = np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.transpose())</span><br></pre></td></tr></table></figure>

<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
[[ 0  4  8 12]
 [ 1  5  9 13]
 [ 2  6 10 14]
 [ 3  7 11 15]]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#rollaxis</span></span><br><span class="line"><span class="comment">#numpy.rollaxis(arr, axis, start)</span></span><br><span class="line"><span class="comment">#将axis轴滚动到start轴</span></span><br><span class="line">a = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(np.rollaxis(a,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="comment">#swapaxis</span></span><br><span class="line"><span class="comment">#numpy.swapaxes(arr, axis1, axis2)&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(np.swapaxes(a,<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<pre><code>[[[0 1]
  [2 3]]

 [[4 5]
  [6 7]]]
[[[0 1]
  [4 5]]

 [[2 3]
  [6 7]]]
[[[0 1]
  [2 3]]

 [[4 5]
  [6 7]]]
[[[0 2]
  [1 3]]

 [[4 6]
  [5 7]]]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改维度</span></span><br><span class="line"><span class="comment">#numpy.squeeze 函数从给定数组的形状中删除一维的条目</span></span><br></pre></td></tr></table></figure>

<pre><code>[[[0 1 2]]

 [[3 4 5]]

 [[6 7 8]]]
[[0 1 2]
 [3 4 5]
 [6 7 8]]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">b = np.arange(<span class="number">3</span>,<span class="number">9</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">c = np.concatenate((a,b),<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">c = np.concatenate((a,b),<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).reshape(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br><span class="line">c = np.concatenate((a,b),<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>

<pre><code>[[1 2 3]
 [4 5 6]
 [3 4 5]
 [6 7 8]]
[[1 2 3 3 4 5]
 [4 5 6 6 7 8]]
(1, 3)
[[1 2 3]
 [4 5 6]
 [1 2 3]]
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#分割 numpy.split(ary, indices_or_sections, axis)</span></span><br><span class="line">a = np.arange(<span class="number">9</span>)</span><br><span class="line">b = np.split(a,[<span class="number">4</span>,<span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<pre><code>[array([0, 1, 2, 3]), array([4, 5, 6]), array([7, 8])]
</code></pre>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>np.add()，subtract()，multiply() 和 divide() +-*/<br>reciprocal 倒数<br>power<br>mod<br>numpy.amin() 和 numpy.amax()<br>numpy.amin() 用于计算数组中的元素沿指定轴的最小值。<br>numpy.amax() 用于计算数组中的元素沿指定轴的最大值。<br>numpy.ptp()函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。<br>numpy.percentile(a, q百分比位数, axis)<br>numpy.median() 中位数<br>numpy.mean() 算数平均值<br>numpy.average() 加权ave<br>np.std() 标准差<br>np.var() 方差</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu - 2698 [USACO12MAR]Flowerpot S</title>
    <url>/2021/10/05/luogu-2698-USACO12MAR-Flowerpot-S/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2698">洛谷P2698 [USACO12MAR]Flowerpot S</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,d;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;a[N];</span><br><span class="line"><span class="keyword">int</span> q1[N];</span><br><span class="line"><span class="keyword">int</span> q2[N];</span><br><span class="line"><span class="keyword">int</span> h1,h2,t1,t2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i].first &gt;&gt; a[i].second ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    h1 = h2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h1 &lt;= t1 &amp;&amp; q1[h1] &lt; l)h1++;<span class="comment">//维护区间 如果队首在左端点左边就右移</span></span><br><span class="line">        <span class="keyword">while</span>(h2 &lt;= t2 &amp;&amp; q2[h2] &lt; l)h2++;</span><br><span class="line">        <span class="keyword">while</span>(a[q1[h1]].second - a[q2[h2]].second &lt; d &amp;&amp; r &lt; n)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">while</span>(h1 &lt;= t1 &amp;&amp; a[q1[t1]].second &lt; a[r].second)t1--;<span class="comment">//注意是队尾和边界比较</span></span><br><span class="line">            q1[++t1] = r;</span><br><span class="line">            <span class="keyword">while</span>(h2 &lt;= t2 &amp;&amp; a[q2[t2]].second &gt; a[r].second)t2--;</span><br><span class="line">            q2[++t2] = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[q1[h1]].second - a[q2[h2]].second &gt;= d)&#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans,a[r].first - a[l].first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans &lt; <span class="number">0x3f3f3f3f</span>)cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/2021/11/15/python/</url>
    <content><![CDATA[<h5 id="组合数据类型"><a href="#组合数据类型" class="headerlink" title="组合数据类型"></a>组合数据类型</h5><p>list  []</p>
<p>tuple  ()</p>
<p>dict – (c++ map)</p>
<blockquote>
<p>word = {‘apple’:’苹果’,’banana’:’香蕉’}</p>
</blockquote>
<blockquote>
<p>scores = {‘小张’:100, ‘小李’:80} </p>
</blockquote>
<blockquote>
<p>grad = {4:’很好’,3: ‘好’,2:’中’,1:’差’,0:’很差’}</p>
</blockquote>
<p>set  {}</p>
<h5 id="list操作"><a href="#list操作" class="headerlink" title="list操作"></a>list操作</h5><p>append</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>切片的语法：[起始:结束:步长] 字符串[start: end: step] </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> s t r i n g</span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">-<span class="number">6</span>-<span class="number">5</span>-<span class="number">4</span>-<span class="number">3</span>-<span class="number">2</span>-<span class="number">1</span></span><br><span class="line">步长为负数时</span><br><span class="line">string = <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line">string[<span class="number">8</span>:<span class="number">2</span>:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;row ol&#x27;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>count</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count</span><br><span class="line">string.count(<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">string.count(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>find</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string.find(<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"><span class="number">4</span> <span class="comment">#返回第一个位置</span></span><br><span class="line">string.find(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">-<span class="number">1</span> <span class="comment">#没找到返回-1</span></span><br></pre></td></tr></table></figure>

<p>index 同find 找不到报错</p>
<p>split</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;habcal_hascshaic_ as&quot;</span></span><br><span class="line">s.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">[<span class="string">&#x27;habcal&#x27;</span>, <span class="string">&#x27;hascshaic&#x27;</span>, <span class="string">&#x27; as&#x27;</span>]</span><br><span class="line">s.split(<span class="string">&quot;_&quot;</span>,<span class="number">1</span>)</span><br><span class="line">[<span class="string">&#x27;habcal&#x27;</span>, <span class="string">&#x27;hascshaic_ as&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>replace</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_string = <span class="string">&#x27;hello_world&#x27;</span></span><br><span class="line">my_string.replace(<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>strip 去除首尾字符,默认为空格或换行符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;    abcnsj  \n &quot;</span></span><br><span class="line">s.strip()</span><br><span class="line"><span class="string">&quot;abcnsj&quot;</span></span><br></pre></td></tr></table></figure>

<p>变形</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_string.upper()<span class="comment">#全大写</span></span><br><span class="line">my_string.lower()<span class="comment">#全小写</span></span><br><span class="line">my_string.capitalize()<span class="comment">#首字母大写</span></span><br></pre></td></tr></table></figure>

<p>格式化输出</p>
<p>f-string</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;Molly&#x27;</span></span><br><span class="line">hight = <span class="number">170.4</span></span><br><span class="line">score_math = <span class="number">95</span></span><br><span class="line">score_english = <span class="number">89</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;大家好！我叫<span class="subst">&#123;name&#125;</span>，我的身高是<span class="subst">&#123;hight:<span class="number">.3</span>f&#125;</span> cm, 数学成绩<span class="subst">&#123;score_math&#125;</span>分,英语成绩<span class="subst">&#123;score_english&#125;</span>分&quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>指针函数调用数组</title>
    <url>/2021/11/07/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><p>数组名是指针常量，指向数组的起始地址。</p>
<p>对于T a[N]，a的类型是T* ,可以将指针赋值成a 使指针指向数组的起始位置</p>
<blockquote>
<p>int a[1000];</p>
<p>int *p = a;</p>
</blockquote>
<p>这也是为什么sort函数是</p>
<blockquote>
<p>sort（a , a + n) //对a[0] 到 a[n-1] 排序</p>
</blockquote>
<p>或者lower_bound</p>
<blockquote>
<p>lower_bound(a , a + n, b) - a</p>
</blockquote>
<p>一维数组作为函数形参有两种写法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"><span class="title">num</span><span class="params">(a)</span></span>;</span><br><span class="line"><span class="comment">//二者等价</span></span><br></pre></td></tr></table></figure>

<p>对形参的数组赋值同样有两种形式如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        b[i]= i;</span><br><span class="line">        *(b + i) = i;<span class="comment">//因为b是指针 对指针所在地址赋值 用 *b = ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>定义二维数组</p>
<blockquote>
<p>T a[n] [m]</p>
</blockquote>
<p>a[i]是一个一维数组 类型是T *</p>
<p>sizeof(a[i]) = sizeof(T) * n</p>
<p>a[i]的地址 = a的起始地址 + i * n * sizeof(T)</p>
<p>调用方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n][<span class="number">3</span>]<span class="comment">//列宽必须一致 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*a)[<span class="number">3</span>])</span><span class="comment">//第二维不能省略</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h5><p>常量名和字符串组名类型都是char*</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span>*)<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hello</p>
<p>h</p>
<p>h</p>
</blockquote>
<p>字符数组表示的字符串可以被修改内容,字符指针表示的数组不能被修改内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">char</span> *p - <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">p[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span><span class="comment">//报错</span></span><br></pre></td></tr></table></figure>



<h5 id="指针数组与数组指针区分"><a href="#指针数组与数组指针区分" class="headerlink" title="指针数组与数组指针区分"></a>指针数组与数组指针区分</h5><p>优先级</p>
<p>() &gt;[] &gt; *</p>
<p>数组指针，定义 int (*p)[n]：</p>
<p>“()”优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>]; <span class="comment">//该语句是定义一个数组指针，指向含4个元素的一维数组。</span></span><br><span class="line"> p=a;        <span class="comment">//将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</span></span><br><span class="line"> p++;       <span class="comment">//该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">5</span>]=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in"><span class="keyword">char</span></span> (*p3)[<span class="number">5</span>] = &amp;a;<span class="comment">//&amp;a 是数组的首地址</span></span><br><span class="line"><span class="built_in"><span class="keyword">char</span></span> (*p4)[<span class="number">5</span>] = a; <span class="comment">//a是数组首元素地址  这里是错误的两边类型不一致</span></span><br><span class="line"><span class="comment">//应该强制类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">char</span> <span class="params">(*p4)</span>[5] </span>=(<span class="built_in"><span class="keyword">char</span></span> (*)[<span class="number">5</span>]) a;</span><br><span class="line">cout &lt;&lt; *p3 &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;(p3) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p4 &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;(p4) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ABCD 0x61fe1b 0x61fe20</p>
<p>ABCD 0x61fe1b 0x61fe20</p>
</blockquote>
<p>指针数组，定义 int *p[n]：</p>
<p>[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p=a；</p>
<p>因为p是个不可知的表示，只存在p[0]、p[1]、p[2]…p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 <em>p=a; 这里</em>p表示指针数组第一个元素的值，a的首地址的值。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>指针</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列学习笔记</title>
    <url>/2021/10/05/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>为了学习单调队列优化dp去了解了前置知识。<br><strong>什么是单调队列呢？</strong><br>顾名思义，单调队列的重点分为 “单调” 和 “队列”<br>“单调” 指的是元素的的 “规律”——递增（或递减）<br>“队列” 指的是元素只能从队头和队尾进行操作<br>实际上维护一段变化区间里的单调的序列。</p>
<p>如<a href="https://oi-wiki.org/ds/monotonous-queue/">oiwiki</a>中有下面的例子</p>
<p>原序列为</p>
<blockquote>
<p>1 3 -1 -3 5 3 6 7</p>
</blockquote>
<p>要求的是每连续的 k 个数中的最小值，<br>操作如下</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">队列状态2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1 入队</td>
<td align="center">{1}</td>
</tr>
<tr>
<td align="center">3 比 1 大，3 入队</td>
<td align="center">{1 3}</td>
</tr>
<tr>
<td align="center">-1 比队列中所有元素小，所以清空队列 -1 入队</td>
<td align="center">{-1}</td>
</tr>
<tr>
<td align="center">-3 比队列中所有元素小，所以清空队列 -3 入队</td>
<td align="center">{-3}</td>
</tr>
<tr>
<td align="center">5 比 -3 大，直接入队</td>
<td align="center">{-3 5}</td>
</tr>
<tr>
<td align="center">3 比 5 小，5 出队，3 入队</td>
<td align="center">{-3 3}</td>
</tr>
<tr>
<td align="center">-3 已经在窗体外，所以 -3 出队；6 比 3 大，6 入队</td>
<td align="center">{3 6}</td>
</tr>
<tr>
<td align="center">7 比 6 大，7 入队</td>
<td align="center">{3 6 7}</td>
</tr>
</tbody></table>
<p>总结下来就是:一旦遇到了破环队列单调性的值,就弹出之前队列中的数值,始终保持队列递增的状态.保证队首始终是当前区间里最小的值.</p>
<p><strong>例题</strong></p>
<p><a href="https://wwwttlll.github.io/2021/10/05/luogu-1886-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">滑动窗口</a></p>
<p><a href="https://wwwttlll.github.io/2021/10/05/luogu-2698-USACO12MAR-Flowerpot-S/">USACO12MAR]Flowerpot S</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>图论篇-最短路</title>
    <url>/2021/09/21/%E5%9B%BE%E8%AE%BA%E7%AF%87-%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="1-最短路"><a href="#1-最短路" class="headerlink" title="1. 最短路"></a>1. 最短路</h2><h4 id="DIJKSTRA"><a href="#DIJKSTRA" class="headerlink" title="DIJKSTRA"></a>DIJKSTRA</h4><p>基于贪心的最短路算法<br>（下面的改进版）基本不能跑负环（跑负环会非常慢）</p>
<p>板子题</p>
<p><a href="https://www.luogu.org/problem/P1339">热浪Heat Wave</a></p>
<p><a href="https://www.luogu.org/problem/P3371">单源最短路径（弱化版）</a></p>
<p><a href="https://www.luogu.org/problem/P4779">单源最短路径（标准版）</a></p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, s;</span><br><span class="line">vector&lt;pair&lt;int, int&gt; &gt; a[100020];</span><br><span class="line">priority_queue&lt;pair&lt;int, int&gt; &gt; q; </span><br><span class="line">// first存距离，second存点的标号，方便找到距离最小的点 </span><br><span class="line">int d[100020];</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        int x, y, z;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        // x 到 y 边权为 z </span><br><span class="line">        a[x].push_back(make_pair(y, z));</span><br><span class="line">        // a[x]是一个vector，记录从x出发的所有边</span><br><span class="line">    &#125;</span><br><span class="line">    memset(d, 0x3f, sizeof d);</span><br><span class="line">    // 初始化所有距离为无穷大 </span><br><span class="line">    d[s] = 0;</span><br><span class="line">    // 起点距离为0 </span><br><span class="line">    q.push(make_pair(-d[s], s));</span><br><span class="line">    // 默认大根堆，但是我们希望距离小的在堆顶，距离存相反数 </span><br><span class="line">    // 刚开始也可以加入其他点，但是其他点距离都是负无穷</span><br><span class="line">    // 加不加无所谓 </span><br><span class="line">    while (q.size() &gt; 0) &#123;</span><br><span class="line">        // 当队列中还有点的时候 </span><br><span class="line">        pair&lt;int, int&gt; u = q.top();</span><br><span class="line">        // 每次选取距离最小的点出堆 </span><br><span class="line">        q.pop();</span><br><span class="line">        if (-u.first &gt; d[u.second]) &#123;</span><br><span class="line">            // 注意到后面修改一个点的距离</span><br><span class="line">            // 并不删除，而是直接重新入堆</span><br><span class="line">            // 所以如果堆中的距离不是最新版本，就忽略 </span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 事实上，如果没有负权边</span><br><span class="line">        // 当u出堆之后，d[u.second]就再也不会改变了 </span><br><span class="line">        // 如果有负权边，这个算法只会慢，而不会错 </span><br><span class="line">        for (int i = 0; i &lt; a[u.second].size(); i++) &#123;</span><br><span class="line">            // 枚举所有出边</span><br><span class="line">            pair&lt;int, int&gt; e = a[u.second][i];</span><br><span class="line">            // 从 u.second 到 e.first 边长为 e.second </span><br><span class="line">            if (d[e.first] &gt; d[u.second] + e.second) &#123;</span><br><span class="line">                d[e.first] = d[u.second] + e.second;</span><br><span class="line">                // 继续松弛操作 </span><br><span class="line">                q.push(make_pair(-d[e.first], e.first));</span><br><span class="line">                // 直接加入新的而不删除旧的 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        printf(&quot;%d%c&quot;, d[i], i == n ? &#x27;\n&#x27; : &#x27; &#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经验总结 </p>
<pre><code>     vector存图会死的！！！

     vector存图会死的！！！
     
     vector存图会死的！！！
     
     比如下面这一道题
</code></pre>
<p>​<br>   <a href="http://poj.org/problem?id=3013">poj 3013 Big Christmas Tree</a></p>
<p>   最短路树  <del>貌似就是正常的最短路</del><br>   ans等于每个节点的点权*该点到根节点的最短路 即 ans= ∑ d[i]*w[i];</p>
<p>   另外这个题不能用vector存图 会TLE 从此痛改前非只用链式前向星</p>
<p>   Code:<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    Name:Big Christmas Tree</span><br><span class="line">	Author:Liberation</span><br><span class="line">	Description:POJ</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long </span><br><span class="line">inline long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">int t,w[100011];</span><br><span class="line">struct edge&#123;</span><br><span class="line">	int next,to,w;</span><br><span class="line">&#125;edge[100011];</span><br><span class="line">int head[100011];</span><br><span class="line">priority_queue&lt;pair&lt;int ,int &gt; &gt;q;</span><br><span class="line">int d[100011];</span><br><span class="line">int v,e,x,y,z,flag,cnt;</span><br><span class="line">int inf;</span><br><span class="line">int ans;</span><br><span class="line">void add(int x,int y,int z)&#123;</span><br><span class="line">	edge[++cnt].next=head[x];</span><br><span class="line">	edge[cnt].w=z;</span><br><span class="line">	edge[cnt].to=y;</span><br><span class="line">	head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">inline void djk()&#123;</span><br><span class="line">	memset(d,0x3f,sizeof d);</span><br><span class="line">	inf=d[0];</span><br><span class="line">	d[1]=0;</span><br><span class="line">	q.push(make_pair(-d[1],1));</span><br><span class="line">	while(q.size())&#123;</span><br><span class="line">		pair&lt;int ,int &gt;u=q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		if(-u.first&gt;d[u.second])&#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=head[u.second];i;i=edge[i].next )&#123;</span><br><span class="line">			int y=edge[i].to,z=edge[i].w;</span><br><span class="line">			if(d[y ]&gt;d[u.second]+z)&#123;</span><br><span class="line">				d[y]=d[u.second]+z;</span><br><span class="line">				q.push(make_pair(-d[y],y));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    //ios::sync_with_stdio(false);</span><br><span class="line">    t=read();</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	cnt=0; </span><br><span class="line">		//memset(edge,0,sizeof edge);</span><br><span class="line">    	v=read();e=read();</span><br><span class="line">    	for(int i=1;i&lt;=v;i++)&#123;</span><br><span class="line">        	w[i]=read();</span><br><span class="line">			head[i]=-1;</span><br><span class="line">	    &#125;</span><br><span class="line">    	for(int i=1;i&lt;=e;i++)&#123;</span><br><span class="line">	    	x=read();y=read();z=read();</span><br><span class="line">	    	add(x,y,z);</span><br><span class="line">	    	add(y,x,z);</span><br><span class="line">	    &#125;</span><br><span class="line">    	djk();</span><br><span class="line">		flag=0;</span><br><span class="line">		ans=0;</span><br><span class="line">    	for(int i=1;i&lt;=v;i++)&#123;</span><br><span class="line">    		if(d[i]&gt;=inf)&#123;</span><br><span class="line">    			flag=1;</span><br><span class="line">				puts(&quot;No Answer&quot;);</span><br><span class="line">    			break;</span><br><span class="line">			&#125;</span><br><span class="line">			ans+=d[i]*w[i];</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag)&#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h4><p><del>（它已经死了）</del>   会各种被卡，但是真的好理解<br>可以用于判负环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">long long d[200011];</span><br><span class="line">vector&lt;pair&lt;int ,int &gt; &gt;a[200011];</span><br><span class="line">bool v[200011];</span><br><span class="line">int n,m,s;</span><br><span class="line">int x,y,z;</span><br><span class="line">queue&lt;long long&gt;q;</span><br><span class="line">void spfa ()&#123;</span><br><span class="line">	memset(d,0x3f,sizeof d);</span><br><span class="line">	memset(v,0,sizeof v);</span><br><span class="line">	d[s]=0;</span><br><span class="line">	v[s]=1;</span><br><span class="line">	q.push(s);</span><br><span class="line">	while(q.size()&gt;0)&#123;</span><br><span class="line">		int x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		v[x]=0;</span><br><span class="line">		for(int i=0;i&lt;a[x].size();i++)&#123;</span><br><span class="line">			pair&lt;int ,int &gt;u=a[x][i];</span><br><span class="line">			if(d[u.first] &gt; d[x] + u.second )&#123;</span><br><span class="line">				d[u.first] = d[x] + u.second;</span><br><span class="line">				if(!v[u.first] )&#123;</span><br><span class="line">				    q.push(u.first ) ;</span><br><span class="line">				    v[u.first ]=1; </span><br><span class="line">			    &#125;</span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();m=read();s=read();</span><br><span class="line">    d[s]=0;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">    	x=read();y=read();z=read();</span><br><span class="line">    	a[x].push_back(make_pair(y,z));</span><br><span class="line">	&#125;</span><br><span class="line">	spfa();</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(d[i]==4557430888798830399)&#123;</span><br><span class="line">		cout&lt;&lt;2147483647&lt;&lt;&quot; &quot;;</span><br><span class="line">		continue;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		cout&lt;&lt;d[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><p>像是区间DP 各种骚操作</p>
<h5 id="1-求稠密图的最短路-O（n-3）"><a href="#1-求稠密图的最短路-O（n-3）" class="headerlink" title="1.求稠密图的最短路 O（n^3）"></a>1.求稠密图的最短路 O（n^3）</h5><p><a href="https://www.luogu.org/problem/P2888">牛栏</a></p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">319</span>][<span class="number">319</span>];</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;t);</span><br><span class="line">	<span class="built_in">memset</span>(a,<span class="number">20</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		a[x][y]=z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i][j]&amp;&amp;a[i][k]&amp;&amp;a[k][j])&#123;</span><br><span class="line">					a[i][j]=<span class="built_in">min</span>(a[i][j],<span class="built_in">max</span>(a[k][j],a[i][k]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">		<span class="keyword">if</span>(a[x][y]!=<span class="number">336860180</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[x][y]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2传递闭包"><a href="#2传递闭包" class="headerlink" title="2传递闭包"></a>2传递闭包</h5><p><a href="http://poj.org/problem?id=3660">Cow Contest</a></p>
<p>数据很小，也可以直接floyd</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">111</span>][<span class="number">111</span>] ;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		f[x][y]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				f[i][j]|=f[i][k]&amp;f[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">bool</span> can=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i!=j&amp;&amp;f[i][j]==<span class="number">0</span>&amp;&amp;f[j][i]==<span class="number">0</span>)&#123;</span><br><span class="line">				can=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(can)&#123;</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="bitset优化传递闭包"><a href="#bitset优化传递闭包" class="headerlink" title="bitset优化传递闭包"></a>bitset优化传递闭包</h5><p><a href="http://poj.org/problem?id=3275">Ranking the Cows</a></p>
<p>单纯传递闭包会超时(只有50分）<br>暴力floyd代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    Name:Ranking the Cows</span><br><span class="line">	Author:Liberation</span><br><span class="line">	Description:POJ</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">int n,m; </span><br><span class="line">int f[1110][1110];</span><br><span class="line">int ans;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    //ios::sync_with_stdio(false);</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">    	int x,y;</span><br><span class="line">    	x=read();y=read();</span><br><span class="line">    	f[x][y]=1;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int k=1;k&lt;=n;k++)&#123;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">				f[i][j]|=f[i][k]&amp;f[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			if(i==j)&#123;</span><br><span class="line">				if(f[i][j])&#123;</span><br><span class="line">					puts(&quot;-1&quot;);</span><br><span class="line">					return 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(!f[i][j]&amp;&amp;!f[j][i])&#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;(ans-n)/2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为n^3会超时</p>
<p>需要bitset优化</p>
<p>将floyd的最后一层枚举bitset<br>Code</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    Name:Ranking the Cows</span><br><span class="line">	Author:Liberation</span><br><span class="line">	Description:POJ</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long read()&#123;</span><br><span class="line">    long long ret=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&gt;&#x27;9&#x27;||ch&lt;&#x27;0&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">int n,m; </span><br><span class="line">bitset&lt;1005&gt;a[1005];</span><br><span class="line">int ans;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    //ios::sync_with_stdio(false);</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    	a[i][i]=1;//初始化 </span><br><span class="line">	&#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">    	int x,y;</span><br><span class="line">    	x=read();y=read();</span><br><span class="line">    	a[x][y]=1;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int k=1;k&lt;=n;k++)&#123;</span><br><span class="line">	//这里k , i 和原来的floyd一样  </span><br><span class="line">	//因为使用了bitset 优化 每一位相当于原来的j </span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(a[i][k])&#123;</span><br><span class="line">				a[i]|=a[k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		ans+=a[i].count();</span><br><span class="line">		//这里 a[i].count() 统计bitset中为1的个数 </span><br><span class="line">		//相当于f[i][j]=1 的个数 </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;n*(n-1)/2-ans+n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="floyd求最小环"><a href="#floyd求最小环" class="headerlink" title="floyd求最小环"></a>floyd求最小环</h5><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1599">HDU 1599 find the mincost route</a></p>
<p>这题要求最小环的长度<br>我们可以用floyd每次松弛前更新答案</p>
<p>每次枚举k时，枚举所有编号小于k的结点i,j（i≠j≠k），可以得出一个经过i,j,k的可行环:a[i][k]+a[k][j]+dist[i][j]，即i到j的最短路加上i到k、j到k的直接距离（若两点之间没有边则为∞）。</p>
<p>Code</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int Maxn=1001;</span><br><span class="line">int n,m,a[Maxn][Maxn],f[Maxn][Maxn],ans;</span><br><span class="line"> </span><br><span class="line">void init()&#123;//初始化</span><br><span class="line">	memset(a,10,sizeof a);</span><br><span class="line">	int x,y,z;</span><br><span class="line">	for (int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">		a[x][y]=a[y][x]=min(a[x][y],z); </span><br><span class="line">		&#125;</span><br><span class="line">	memcpy(f,a,sizeof a);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void work()&#123;</span><br><span class="line">	ans=0x7fffff;</span><br><span class="line">	for (int k=1;k&lt;=n;k++)&#123;</span><br><span class="line">		for (int i=1;i&lt;k;i++)</span><br><span class="line">			for (int j=1;j&lt;i;j++)</span><br><span class="line">            //这里注意i j小于K</span><br><span class="line">            //因为要枚举k之前的点 </span><br><span class="line">				ans=min(ans,a[i][k]+a[k][j]+f[i][j]);</span><br><span class="line">		for (int i=1;i&lt;=n;i++)</span><br><span class="line">			for (int j=1;j&lt;=n;j++)	</span><br><span class="line">				f[i][j]=min(f[i][j],f[i][k]+f[k][j]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">	while (~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">		init();</span><br><span class="line">		work();</span><br><span class="line">		if (ans==0x7fffff) cout&lt;&lt;&quot;It&#x27;s impossible.\n&quot;;</span><br><span class="line">		   else cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://poj.org/problem?id=1734">Sightseeing trip</a></p>
<p>这题有点毒瘤 求最小环的路径 </p>
<p>所以每次记更新最小的时候都应该更新一遍路径</p>
<p>Code</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define inf 0x7ffffff</span><br><span class="line"></span><br><span class="line">int f[111][111],pre[111][111],a[111][111],print[111];</span><br><span class="line">int n,m,cnt,ans=inf,x,y,z;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			f[i][j]=f[j][i]=a[i][j]=a[j][i]=inf;</span><br><span class="line">			pre[i][j]=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">		a[x][y]=a[y][x]=f[x][y]=f[y][x]=min(a[x][y],z);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void floyd()&#123;</span><br><span class="line">	for(int k=1;k&lt;=n;k++)&#123;</span><br><span class="line">		for(int i=1;i&lt;k;i++)&#123;</span><br><span class="line">			for(int j=i+1;j&lt;k;j++)&#123;</span><br><span class="line">				if(a[i][k]+a[k][j]+f[i][j]&lt;ans)&#123;</span><br><span class="line">					ans=a[i][k]+a[k][j]+f[i][j];</span><br><span class="line">					cnt=0;//更新路径</span><br><span class="line">                    //因为有special judge 所以顺序无所谓</span><br><span class="line">					int t=j;</span><br><span class="line">					while(t!=i)&#123;</span><br><span class="line">						print[++cnt]=t;</span><br><span class="line">						t=pre[i][t];</span><br><span class="line">					&#125;</span><br><span class="line">					print[++cnt]=i;</span><br><span class="line">					print[++cnt]=k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">			for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">				if(f[i][k]+f[k][j]&lt;f[i][j])&#123;</span><br><span class="line">					f[i][j]=f[i][k]+f[k][j];</span><br><span class="line">					pre[i][j]=pre[k][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	init();</span><br><span class="line">	floyd();</span><br><span class="line">	if(ans==inf)&#123;</span><br><span class="line">		puts(&quot;No solution.&quot;);</span><br><span class="line">		return  0;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">        printf(&quot;%d&quot;, print[1]);</span><br><span class="line">        for (int i = 2; i &lt;= cnt; i++)</span><br><span class="line">            printf(&quot; %d&quot;, print[i]);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>教主的魔法</title>
    <url>/2021/11/25/%E6%95%99%E4%B8%BB%E7%9A%84%E9%AD%94%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2801">题目链接</a></p>
<p>分块板子题 求数列在[l,r]内的数有多少大于/小于/大于等于/小于等于k</p>
<p>考虑分块做法</p>
<p>新建一个vector，对于每块内的数据排序，然后通过二分找到该块内大于k的数量。</p>
<p>记得初始化时也要排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> id[N],len;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N], size[N], st[N], ed[N];</span><br><span class="line"><span class="comment">//单点 区间标记（类似懒标） 大小 每块开始位置 结束位置</span></span><br><span class="line"><span class="keyword">int</span> n,q; </span><br><span class="line">vector &lt;<span class="keyword">int</span> &gt;v[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size[x]; i++)&#123;</span><br><span class="line">        v[x][i] = a[st[x]+ i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v[x].<span class="built_in">begin</span>(),v[x].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sid = id[l], eid = id[r];</span><br><span class="line">    <span class="keyword">if</span>(sid == eid)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">            a[i] += k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update</span>(sid);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; id[i] == sid; i++)&#123;</span><br><span class="line">        a[i] += k;<span class="comment">//零散单点暴力修改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = sid + <span class="number">1</span>; i &lt; eid; i++)&#123;</span><br><span class="line">        s[i] += k;<span class="comment">//区间标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r; id[i] == eid; i--)&#123;</span><br><span class="line">        a[i] += k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(sid);</span><br><span class="line">    <span class="built_in">update</span>(eid);<span class="comment">//更新后的区间排序 只需要更新零散的区间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//cout &lt;&lt; sid &lt;&lt; &quot; &quot; &lt;&lt; size[sid] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; eid &lt;&lt; &quot; &quot; &lt;&lt; size[eid] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sid = id[l];</span><br><span class="line">    <span class="keyword">int</span> eid = id[r];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(sid == eid)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] + s[sid] &gt;= k)&#123;</span><br><span class="line">                ans ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l ;id[i] == sid; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] + s[sid] &gt;= k)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r; id[i] == eid; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] + s[eid] &gt;= k)&#123;<span class="comment">//单点加上区间标记</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = sid + <span class="number">1</span>; i &lt; eid; i++)&#123;</span><br><span class="line">        ans += v[i].<span class="built_in">end</span>() - <span class="built_in">lower_bound</span>(v[i].<span class="built_in">begin</span>(), v[i].<span class="built_in">end</span>(), k - s[i]);</span><br><span class="line">    &#125;<span class="comment">//二分查找 </span></span><br><span class="line">    <span class="comment">//大于等于 lower_bound</span></span><br><span class="line">    <span class="comment">//大于 upper_bound</span></span><br><span class="line">    <span class="comment">//小于 size - lower_bound</span></span><br><span class="line">    <span class="comment">//小于等于 size - upper_bound</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();q = <span class="built_in">read</span>();</span><br><span class="line">    len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len ; i++)&#123;</span><br><span class="line">        st[i] = n / (len) * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        ed[i] = n / len * i;</span><br><span class="line">        <span class="comment">//这里有两种写法 一个是len + 1 块 把len * len 后面的块放在len + 1块</span></span><br><span class="line">        <span class="comment">//另一种是将 后面的块并入 len 块</span></span><br><span class="line">        <span class="comment">//一开始将两种写法写混了QAQ</span></span><br><span class="line">    &#125;</span><br><span class="line">    ed[len] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)&#123;</span><br><span class="line">        size[i] = ed[i] - st[i] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = st[i]; j &lt;= ed[i]; j++)&#123;</span><br><span class="line">            id[j] = i;</span><br><span class="line">            v[i].<span class="built_in">push_back</span>(a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len; i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(), v[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;<span class="comment">//vector初始化后一定记得排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        x = <span class="built_in">read</span>(); y = <span class="built_in">read</span>(); z = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">add</span>(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="built_in">query</span>(x,y,z);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>分块</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>显式模板实参</title>
    <url>/2021/12/29/%E6%98%BE%E5%BC%8F%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82/</url>
    <content><![CDATA[<h4 id="函数模-mu-板"><a href="#函数模-mu-板" class="headerlink" title="函数模(mu)板"></a>函数模(mu)板</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//隐式调用</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">swap</span>(a,b);</span><br></pre></td></tr></table></figure>

<p>在一些情况下通过隐式调用编译器无法推演参数类型，这是需要进行显式调用。</p>
<p><strong>显示模板实参</strong>的格式为<strong>在调用模板函数的时候在函数名后用&lt;&gt;尖括号括住要显示的类型</strong></p>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(T a, T b)</span></span>&#123;&#125;</span><br><span class="line"><span class="built_in">h</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//报错</span></span><br><span class="line">h&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">1.1</span>)<span class="comment">//正确写法</span></span><br></pre></td></tr></table></figure>

<p>**对于多个模板参数&lt;&gt;中的类型依次对应每个参数，只能省略掉尾部的实参 **</p>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class a, class b, class c&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get</span><span class="params">(b x, c y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line">get&lt;<span class="keyword">double</span>,<span class="keyword">int</span>&gt;(<span class="number">1.1</span>,<span class="number">1</span>);<span class="comment">//输出1</span></span><br><span class="line">get&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;(<span class="number">1.1</span>,<span class="number">1</span>);<span class="comment">//输出1.1</span></span><br><span class="line">get&lt;<span class="keyword">double</span>,<span class="keyword">int</span>,<span class="keyword">double</span>&gt;(<span class="number">1.1</span>,<span class="number">1.2</span>);<span class="comment">//输出1.2</span></span><br></pre></td></tr></table></figure>

<h4 id="必须使用显性调用的情况"><a href="#必须使用显性调用的情况" class="headerlink" title="必须使用显性调用的情况"></a>必须使用显性调用的情况</h4><h5 id="1-同一个模板实参类型不一致的的情况"><a href="#1-同一个模板实参类型不一致的的情况" class="headerlink" title="1.同一个模板实参类型不一致的的情况"></a>1.同一个模板实参类型不一致的的情况</h5><p>如上上代码段</p>
<h5 id="2-函数返回值类型为模板实参类型"><a href="#2-函数返回值类型为模板实参类型" class="headerlink" title="2.函数返回值类型为模板实参类型"></a>2.函数返回值类型为模板实参类型</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class a, class b, class c&gt;</span></span><br><span class="line"><span class="function">a <span class="title">get</span><span class="params">(b x, c y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这种情况下a的类型无法推演</span></span><br><span class="line">get&lt;<span class="keyword">int</span>,<span class="keyword">double</span>,<span class="keyword">double</span>&gt;(<span class="number">1.1</span>,<span class="number">1.2</span>);<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h5 id="3-应用于模板函数的参数中没有出现模板形参的情况"><a href="#3-应用于模板函数的参数中没有出现模板形参的情况" class="headerlink" title="3.应用于模板函数的参数中没有出现模板形参的情况"></a>3.应用于模板函数的参数中没有出现模板形参的情况</h5>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>c++</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>xcpc算法模板</title>
    <url>/2022/07/06/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<ol>
<li><a href="#图论">图论</a><ol>
<li><a href="#单源最短路径-dijkstra">单源最短路径 dijkstra</a></li>
<li><a href="#单源最短路径-spfa">单源最短路径 spfa</a></li>
<li><a href="#最短路spfa-slflll优化">最短路spfa SLF+LLL优化</a></li>
<li><a href="#次短路">次短路</a></li>
<li><a href="#最近公共祖先">最近公共祖先</a></li>
<li><a href="#tarjan-缩点">tarjan 缩点</a></li>
</ol>
</li>
<li><a href="#数据结构">数据结构</a><ol>
<li><a href="#线段树模板2-区间加-乘">线段树模板2 区间加 乘</a></li>
<li><a href="#主席树区间第k大">主席树区间第k大</a></li>
</ol>
</li>
<li><a href="#字符串">字符串</a><ol>
<li><a href="#ac自动机">ac自动机</a></li>
</ol>
</li>
<li><a href="#数学">数学</a><ol>
<li><a href="#线性回归-最小二乘法">线性回归 最小二乘法</a></li>
<li><a href="#组合数">组合数</a></li>
</ol>
</li>
<li><a href="#dp">dp</a></li>
<li><a href="#随机">随机</a></li>
<li><a href="#生成数据与对拍">生成数据与对拍</a><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="单源最短路径-dijkstra"><a href="#单源最短路径-dijkstra" class="headerlink" title="单源最短路径 dijkstra"></a>单源最短路径 dijkstra</h3></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">11</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span> &gt; &gt;q;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt;&gt;v[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    d[root] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,root));</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u1 = q.<span class="built_in">top</span>().first;</span><br><span class="line">        <span class="keyword">int</span> u2 = q.<span class="built_in">top</span>().second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(-u1 &gt; d[u2])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[u2].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = v[u2][i].first;</span><br><span class="line">            <span class="keyword">int</span> v2 = v[u2][i].second;</span><br><span class="line">            <span class="keyword">if</span>(d[v1] &gt; d[u2] + v2)&#123;</span><br><span class="line">                d[v1] = d[u2] + v2;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-d[v1],v1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); s = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        x = <span class="built_in">read</span>(); y = <span class="built_in">read</span>(); z = <span class="built_in">read</span>();</span><br><span class="line">        v[x].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(y,z));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单源最短路径-spfa"><a href="#单源最短路径-spfa" class="headerlink" title="单源最短路径 spfa"></a>单源最短路径 spfa</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">100011</span>];</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">100011</span>];</span><br><span class="line">queue&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; &gt;a[<span class="number">100011</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">	<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);</span><br><span class="line">	d[x]=<span class="number">0</span>;</span><br><span class="line">	v[x]=<span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(x);</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		v[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">			pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt;e=a[u][i];</span><br><span class="line">			<span class="keyword">if</span>(d[e.first]&gt;d[u]+e.second)&#123;</span><br><span class="line">				d[e.first]=d[u]+e.second;</span><br><span class="line">				<span class="keyword">if</span>(!v[e.first])&#123;</span><br><span class="line">					q.<span class="built_in">push</span>(e.first);</span><br><span class="line">					v[e.first]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,s;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y,z;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">		a[x].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(y,z));</span><br><span class="line">		<span class="comment">//a[y].push_back(make_pair(x,z));</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">spfa</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(d[i]==<span class="number">4557430888798830399</span>)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="number">2147483647</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;d[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="最短路spfa-SLF-LLL优化"><a href="#最短路spfa-SLF-LLL优化" class="headerlink" title="最短路spfa SLF+LLL优化"></a>最短路spfa SLF+LLL优化</h3><p>SLF(Small Label First)优化思路：将原队列改成双端队列，对要加入队列的点 p，如果 dist[p] 小于队头元素 u 的 dist[u]，将其插入到队头，否则插入到队尾。</p>
<p>LLL((Large Label Last)优化思路：对每个要出队的队头元素 u，比较 dist[u] 和队列中点的 dist 的平均值，如果 dist[u] 更大，将其弹出放到队尾，然后取队首元素进行相同操作，直到队头元素的 dist 小于等于平均值。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa_slf_lll</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	dis[S]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	q.<span class="built_in">push_back</span>(S);</span><br><span class="line">	<span class="keyword">int</span> sum=dis[S];<span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">	cnt[S]++;</span><br><span class="line">	visited[S]=<span class="literal">true</span>; <span class="comment">//入队即true。</span></span><br><span class="line">	<span class="keyword">int</span> flag=<span class="number">0</span>;         <span class="comment">//标志，若为真，则表示存在负环。</span></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		temp=q.<span class="built_in">front</span>();</span><br><span class="line">		<span class="keyword">while</span>(dis[temp]*num&gt;sum)&#123;</span><br><span class="line">			<span class="comment">//lll优化</span></span><br><span class="line">			q.<span class="built_in">pop_front</span>();</span><br><span class="line">			q.<span class="built_in">push_back</span>(temp);</span><br><span class="line">			temp=q.<span class="built_in">front</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		q.<span class="built_in">pop_front</span>();</span><br><span class="line">		sum-=dis[temp];</span><br><span class="line">		num--;</span><br><span class="line">		visited[temp]=<span class="literal">false</span>; <span class="comment">//出队则false。</span></span><br><span class="line">		<span class="keyword">int</span> v,w;</span><br><span class="line">		<span class="keyword">int</span> t=graph[temp].<span class="built_in">size</span>();<span class="comment">//避免多次调用此函数。</span></span><br><span class="line">        <span class="comment">//松弛操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">			v=graph[temp][i].to;</span><br><span class="line">			w=graph[temp][i].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[v]&gt;dis[temp]+w)&#123;</span><br><span class="line">				dis[v]=dis[temp]+w;<span class="comment">//更新最短路径</span></span><br><span class="line">				<span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">					<span class="comment">//判断是否在队列中</span></span><br><span class="line">					<span class="keyword">if</span>(!q.<span class="built_in">empty</span>()&amp;&amp;dis[v]&gt;dis[q.<span class="built_in">front</span>()])&#123;</span><br><span class="line">						<span class="comment">//和队头元素进行比较。</span></span><br><span class="line">						q.<span class="built_in">push_back</span>(v);<span class="comment">//大于入队尾</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> q.<span class="built_in">push_front</span>(v); <span class="comment">//小于入队头</span></span><br><span class="line">					sum+=dis[v];</span><br><span class="line">					num++;</span><br><span class="line">					cnt[v]++;</span><br><span class="line">					<span class="keyword">if</span>(cnt[v]&gt;n)&#123;flag=<span class="number">1</span>;<span class="keyword">return</span> flag;&#125;</span><br><span class="line">					visited[v]=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="次短路"><a href="#次短路" class="headerlink" title="次短路"></a>次短路</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,z;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; &gt;a[<span class="number">100019</span>];</span><br><span class="line"><span class="keyword">int</span> d1[<span class="number">5019</span>];</span><br><span class="line"><span class="keyword">int</span> d2[<span class="number">5019</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">djk1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(d1,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d1);</span><br><span class="line">	d1[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-d1[<span class="number">1</span>],<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt;u=q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(-u.first&gt;d1[u.second])&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a[u.second].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">			pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; e = a[u.second][i];</span><br><span class="line">			<span class="keyword">if</span> (d1[e.first] &gt; d1[u.second] + e.second) &#123;</span><br><span class="line">				d1[e.first] = d1[u.second] + e.second;</span><br><span class="line">				q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-d1[e.first], e.first));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">djk2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(d2,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d2);</span><br><span class="line">	d2[n]=<span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-d2[n],n));</span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt;u=q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(-u.first&gt;d2[u.second])&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a[u.second].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">			pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; e = a[u.second][i];</span><br><span class="line">			<span class="keyword">if</span> (d2[e.first] &gt; d2[u.second] + e.second) &#123;</span><br><span class="line">				d2[e.first] = d2[u.second] + e.second;</span><br><span class="line">				q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-d2[e.first], e.first));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">    	a[x].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(y,z));</span><br><span class="line">    	a[y].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(x,z));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">djk1</span>();</span><br><span class="line">	<span class="built_in">djk2</span>();</span><br><span class="line">	<span class="keyword">int</span> ans=d1[n];</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i][j].second + d1[i] + d2[a[i][j].first] &gt; d1[n])&#123;</span><br><span class="line">                cnt=<span class="built_in">min</span>(cnt,a[i][j].second + d1[i] + d2[a[i][j].first]);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">int</span> n,m,x,y,s;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">500011</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">500011</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span> &gt;a[<span class="number">500011</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	f[x][<span class="number">0</span>]=y;</span><br><span class="line">	d[x]=d[y]+<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;x&lt;&lt;&quot;&quot;&lt;&lt;d[x]&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)&#123;</span><br><span class="line">		f[x][i]=f[f[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[x][i]!=y)&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(a[x][i],x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(d[x]&lt;d[y])&#123;</span><br><span class="line">		<span class="built_in">swap</span>(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> dd=d[x]-d[y];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dd&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">			x=f[x][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x==y)&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[x][i]!=f[y][i])&#123;</span><br><span class="line">			x=f[x][i];</span><br><span class="line">			y=f[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">		a[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		a[y].<span class="built_in">push_back</span>(x); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">lca</span>(x,y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="tarjan-缩点"><a href="#tarjan-缩点" class="headerlink" title="tarjan 缩点"></a>tarjan 缩点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;g[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> x[N],y[N],a[N];</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>, tot = <span class="number">0</span>,top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> col[N],dfn[N],low[N],st[N],sz[N],pd[N],f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx;<span class="comment">//时间戳 回溯值</span></span><br><span class="line">    st[++top] = u; <span class="comment">//入栈</span></span><br><span class="line">    pd[u] = <span class="number">1</span>; <span class="comment">//判断是否在栈中 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = g[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123; </span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[v],low[u]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pd[v])&#123;</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u])&#123;</span><br><span class="line">        tot ++;<span class="comment">//强连通分量的编号</span></span><br><span class="line">        <span class="keyword">while</span>(st[top + <span class="number">1</span>] != u)&#123;</span><br><span class="line">            col[st[top]] = tot;</span><br><span class="line">            sz[tot] += a[st[top]]; <span class="comment">//强连通分量的大小 || 权值和 （依照题目更改）</span></span><br><span class="line">            pd[st[top--]] = <span class="number">0</span>;<span class="comment">//出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">()</span></span>&#123;<span class="comment">//重建图</span></span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(col[x[i]] != col[y[i]])&#123;</span><br><span class="line">            g[col[x[i]]].<span class="built_in">push_back</span>(col[y[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="线段树模板2-区间加-乘"><a href="#线段树模板2-区间加-乘" class="headerlink" title="线段树模板2 区间加 乘"></a>线段树模板2 区间加 乘</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson x &lt;&lt; 1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson x &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">11</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,add,mul,sum;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mul(x) t[x].mul</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line">&#125;t[<span class="number">4</span> * N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">l</span>(x) = l;</span><br><span class="line">    <span class="built_in">r</span>(x) = r;</span><br><span class="line">    <span class="built_in">add</span>(x) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">mul</span>(x) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="built_in">sum</span>(x) = a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lson,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rson,mid + <span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">sum</span>(x) = (<span class="built_in">sum</span>(lson) + <span class="built_in">sum</span>(rson)) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">mul</span>(lson) = <span class="built_in">mul</span>(lson) * <span class="built_in">mul</span>(x) % p;</span><br><span class="line">    <span class="built_in">mul</span>(rson) = <span class="built_in">mul</span>(rson) * <span class="built_in">mul</span>(x) % p;</span><br><span class="line">    <span class="built_in">add</span>(lson) = <span class="built_in">add</span>(lson) * <span class="built_in">mul</span>(x) % p;</span><br><span class="line">    <span class="built_in">add</span>(rson) = <span class="built_in">add</span>(rson) * <span class="built_in">mul</span>(x) % p;</span><br><span class="line">    <span class="built_in">sum</span>(lson) = (<span class="built_in">sum</span>(lson) * <span class="built_in">mul</span>(x)) % p;</span><br><span class="line">    <span class="built_in">sum</span>(rson) = (<span class="built_in">sum</span>(rson) * <span class="built_in">mul</span>(x)) % p;</span><br><span class="line">    <span class="built_in">mul</span>(x) = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(lson) = (<span class="built_in">add</span>(lson) + <span class="built_in">add</span>(x))%p;</span><br><span class="line">    <span class="built_in">add</span>(rson) = (<span class="built_in">add</span>(rson) + <span class="built_in">add</span>(x))%p;</span><br><span class="line">    <span class="built_in">sum</span>(lson) = (<span class="built_in">sum</span>(lson) + <span class="built_in">add</span>(x) * (<span class="built_in">r</span>(lson) - <span class="built_in">l</span>(lson) + <span class="number">1</span>)) % p;</span><br><span class="line">    <span class="built_in">sum</span>(rson) = (<span class="built_in">sum</span>(rson) + <span class="built_in">add</span>(x) * (<span class="built_in">r</span>(rson) - <span class="built_in">l</span>(rson) + <span class="number">1</span>)) % p;</span><br><span class="line">    <span class="built_in">add</span>(x) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= <span class="built_in">l</span>(x) &amp;&amp; <span class="built_in">r</span>(x) &lt;= r)&#123;</span><br><span class="line">        <span class="built_in">add</span>(x) += k;</span><br><span class="line">        <span class="built_in">add</span>(x) %= p;</span><br><span class="line">        <span class="built_in">sum</span>(x) = (<span class="built_in">sum</span>(x) + k * (<span class="built_in">r</span>(x) - <span class="built_in">l</span>(x) + <span class="number">1</span>)) % p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">l</span>(x) + <span class="built_in">r</span>(x)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">A</span>(lson,l,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)&#123;</span><br><span class="line">        <span class="built_in">A</span>(rson,l,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sum</span>(x) = (<span class="built_in">sum</span>(lson) + <span class="built_in">sum</span>(rson))%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">M</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= <span class="built_in">l</span>(x) &amp;&amp; <span class="built_in">r</span>(x) &lt;= r)&#123;</span><br><span class="line">        <span class="built_in">mul</span>(x) = <span class="built_in">mul</span>(x) * k % p;</span><br><span class="line">        <span class="built_in">add</span>(x) = <span class="built_in">add</span>(x) * k % p;</span><br><span class="line">        <span class="built_in">sum</span>(x) = <span class="built_in">sum</span>(x) * k % p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">l</span>(x) + <span class="built_in">r</span>(x)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">M</span>(lson,l,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)&#123;</span><br><span class="line">        <span class="built_in">M</span>(rson,l,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sum</span>(x) = (<span class="built_in">sum</span>(lson) + <span class="built_in">sum</span>(rson))%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= <span class="built_in">l</span>(x) &amp;&amp; <span class="built_in">r</span>(x) &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(x);</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">l</span>(x) + <span class="built_in">r</span>(x)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)&#123;</span><br><span class="line">        ans += <span class="built_in">query</span>(lson,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)&#123;</span><br><span class="line">        ans += <span class="built_in">query</span>(rson,l,r);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> ans%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op,x,y,z;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="built_in">M</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="built_in">A</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">3</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>,x,y) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主席树区间第k大"><a href="#主席树区间第k大" class="headerlink" title="主席树区间第k大"></a>主席树区间第k大</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tii tuple<span class="meta-string">&lt;int,int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> L[N * <span class="number">40</span>],R[N * <span class="number">40</span>],sum[N * <span class="number">40</span>],T[N * <span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++cnt;</span><br><span class="line">    L[rt] = L[pre]; R[rt] = R[pre]; sum[rt] = sum[pre] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">            L[rt] = <span class="built_in">update</span>(L[pre], l , mid , x);</span><br><span class="line">        &#125;  <span class="keyword">else</span>&#123;</span><br><span class="line">            R[rt] = <span class="built_in">update</span>(R[pre], mid + <span class="number">1</span>, r, x);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> l, <span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = sum[L[v]] - sum[L[u]];<span class="comment">//左子树的和</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= k)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(L[u],L[v],l,mid,k);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(R[u],R[v],mid + <span class="number">1</span>,r,k - x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">unique</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n) - b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + len, a[i]) -b;</span><br><span class="line">        T[i] = <span class="built_in">update</span>(T[i - <span class="number">1</span>],<span class="number">1</span>,len,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        x = <span class="built_in">read</span>(); y = <span class="built_in">read</span>(); z= <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">query</span>(T[x - <span class="number">1</span>], T[y], <span class="number">1</span>, len, z);</span><br><span class="line">        cout &lt;&lt; b[ans] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="ac自动机"><a href="#ac自动机" class="headerlink" title="ac自动机"></a>ac自动机</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">156</span>, L = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> AC &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SZ = N * <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">int</span> tot, tr[SZ][<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> fail[SZ], idx[SZ], val[SZ];</span><br><span class="line">    <span class="keyword">int</span> cnt[N];  <span class="comment">// 记录第 i 个字符串的出现次数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(fail));</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(tr));</span><br><span class="line">        <span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(val));</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(idx, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(idx));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> id)</span> </span>&#123;  <span class="comment">// id 表示原始字符串的编号</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tr[u][s[i] - <span class="string">&#x27;a&#x27;</span>]) tr[u][s[i] - <span class="string">&#x27;a&#x27;</span>] = ++tot;</span><br><span class="line">            u = tr[u][s[i] - <span class="string">&#x27;a&#x27;</span>];  <span class="comment">// 转移</span></span><br><span class="line">        &#125;</span><br><span class="line">        idx[u] = id;  <span class="comment">// 以 u 为结尾的字符串编号为 idx[u]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (tr[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tr[u][i]) &#123;</span><br><span class="line">                    fail[tr[u][i]] = tr[fail[u]][i];  <span class="comment">// fail数组：同一字符可以匹配的其他位置</span></span><br><span class="line">                    q.<span class="built_in">push</span>(tr[u][i]);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    tr[u][i] = tr[fail[u]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span> </span>&#123;  <span class="comment">// 返回最大的出现次数</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; t[i]; i++) &#123;</span><br><span class="line">            u = tr[u][t[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = u; j; j = fail[j]) val[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tot; i++)</span><br><span class="line">            <span class="keyword">if</span> (idx[i]) res = <span class="built_in">max</span>(res, val[i]), cnt[idx[i]] = val[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// namespace AC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[N][<span class="number">100</span>], t[L];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		AC::<span class="built_in">init</span>();  <span class="comment">// 数组清零</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>), AC::<span class="built_in">insert</span>(s[i], i);  <span class="comment">// 需要记录该字符串的序号</span></span><br><span class="line">		AC::<span class="built_in">build</span>();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> x = AC::<span class="built_in">query</span>(t);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">if</span> (AC::cnt[i] == x) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="线性回归-最小二乘法"><a href="#线性回归-最小二乘法" class="headerlink" title="线性回归 最小二乘法"></a>线性回归 最小二乘法</h3><p>公式</p>
<script type="math/tex; mode=display">
\begin{align}

y = {\theta}_0x+{\theta}_1\\
\theta_1 = {\sum_{i = 1}^n{x_i}^2\sum_{i = 1}^ny_i-\sum_{i = 1}^nx_i\sum_{i = 1}^n{x_iy_i} \over n\sum_{i = 1}^nx_i^2 - (\sum_{i = 1}^nx_i)^2}\\ 

\theta_0 = {n\sum_{i = 1}^n{x_iy_i}-\sum_{i = 1}^n{x_i}\sum_{i = 1}^n{y_i} \over n\sum_{i = 1}^nx_i^2 - (\sum_{i = 1}^nx_i)^2}
\end{align}</script><h3 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">power</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span> % mod;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> fact[N + <span class="number">10</span>], inv_fact[N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span> || m &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fact[n] * inv_fact[m] % mod * inv_fact[n - m] % mod; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        fact[i] = fact[i - <span class="number">1</span>] * i % mod; </span><br><span class="line">    &#125; </span><br><span class="line">    inv_fact[N] = <span class="built_in">power</span>(fact[N], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        inv_fact[i - <span class="number">1</span>] = inv_fact[i] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><h2 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h2><h2 id="生成数据与对拍"><a href="#生成数据与对拍" class="headerlink" title="生成数据与对拍"></a>生成数据与对拍</h2>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题顺序理解</title>
    <url>/2021/09/21/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E9%A1%BA%E5%BA%8F%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>一直以来写背包问题全靠背模板，对于01背包和完全背包的顺序问题一直存疑而不得理解，今天巧合之下明白了01背包倒序而完全背包顺序的原因，特此记录。<br>01背包要求每个物品只能取一次，在二维状态下状态转移方程如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][m], f[i - <span class="number">1</span>][m - w[i]] + v[i]);</span><br></pre></td></tr></table></figure>
<p>f[i][j]表示从前i个物品中选出总重量不超过j的物品的最大价值。<br>由此可见每个状态都来自于前一个物品</p>
<p>而完全背包中， 每个物品可以无限取，在二维状态下状态转移方程如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i][j] = <span class="built_in">max</span>(f[i][j] , f[i - <span class="number">1</span>][j - k * w[i]] + k*v[i]);</span><br></pre></td></tr></table></figure>
<p>当然k的重复计算可以简化<br>过程如下<br><img src="https://img-blog.csdnimg.cn/img_convert/77511d81c8abf5204da97ead1b8845ef.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j],f[i][j - w[i]] + v[i]);</span><br></pre></td></tr></table></figure>
<p>可以看出完全背包的状态来源于之前的自己</p>
<p>在通过滚动数组优化成一维后，两者的唯一差别只有枚举j的顺序<br>01</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = W; j &gt;= w[i]; j--)&#123;</span><br><span class="line">		f[j] = <span class="built_in">max</span>(f[j - w[i]] + v[i], f[j]);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完全</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j =  w[i]; j &lt;= W; j++)&#123;</span><br><span class="line">		f[j] = <span class="built_in">max</span>(f[j - w[i]] + v[i], f[j]);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会这样呢<br>举个例子<br>假设你有一个重为2的物品<br>（图中的数学代表枚举的 j）<br><img src="https://img-blog.csdnimg.cn/img_convert/8a7a155271035e0623ac645a3e85f72e.png#pic_center" alt="在这里插入图片描述"><br>在枚举j的过程中，如果顺序枚举 会先更新j = 2的情况，然后根据j = 2 的情况更新j = 4，同理后面的6，8，10 …这样相当于每个物品可以多次使用，符合完全背包的条件。</p>
<p>而如果倒序枚举 ，会先更新4 然后再更新2 2中的状态与4无关，相当于每个物品只能用一次，符合01 背包。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>dp</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔问题</title>
    <url>/2021/10/31/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>汉诺塔问题是非常经典的递归问题，之前只知道问题的移动步数的结论是2 ^ n - 1,具体过程并未思考。今天通过做题了解到这是明显的递归，过程如下。</p>
<p>有a b c三根柱子，先从n = 1 的情况开始。先将a 中的盘子移到 c中 ，记作<br>$$<br> f(1,a,c).<br>$$</p>
<p> 如果n = 2呢？显然，我们要先将a 中最上面的一个移到b中，再将a中剩下的一个移到c中， 最后将b中的一个移到c中。</p>
<p>那么操作过程是<br>$$<br>f(1,a,b)  -&gt; f(1,a,c) -&gt;f(1,b,c)<br>$$</p>
<p>将情况推广到n。我们需要将a中的n-1个移入b中 将 a中剩下的1个移入c中 在将b中的n-1个移入c中<br>$$<br>f(n-1,a,b)  -&gt; f(1,a,c) -&gt;f(n-1,b,c)<br>$$<br>发现规律了吗，每次的<br>$$<br>f(n) = 2*f(n-1)+1<br>$$<br>通过递归，我们可以得到f(n-1) 来更新f(n);</p>
<p>最终过程代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> a,<span class="keyword">char</span> b, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c----%c\n&quot;</span>,a,c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(n<span class="number">-1</span>,a,c,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c----%c\n&quot;</span>,a,c);</span><br><span class="line">    <span class="built_in">dfs</span>(n<span class="number">-1</span>,b,a,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt != <span class="number">0</span>)cout &lt;&lt; endl;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="built_in">dfs</span>(n,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>进制-牛客寒假集训营</title>
    <url>/2022/02/20/%E8%BF%9B%E5%88%B6-%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD%E8%90%A5/</url>
    <content><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/contest/23479/B">https://ac.nowcoder.com/acm/contest/23479/B</a><br>来源：牛客网</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>小红拿到了一个长度为 <em>n</em> 的数字串 <em>s</em>（只有 ‘0’ ~ ‘9’ 这十种字符），她有 <em>q</em> 次以下两种操作： </p>
<p> 第一种： 输入1 x y，修改第 <em>x</em> 个字符为 <em>y</em> ，即令 <em>x = y</em></p>
<p>  第二种： 输出 2 x y ，代表查询区间 [x,y]，该区间子串所能表示的某进制的最小值（进制必须合法，且必须是二进制到十进制之间，可以包含前导零），对 1000000007 取模。</p>
<p>例如若查询的子串为 “47”，其能表示的最小值是八进制代表的”47”，其数值为39，因此输出39。如果用十进制表示，则数值47，比39大。 </p>
<p>  例如若查询的子串为 “10000”，其能表示的最小值是二进制代表的”10000”，其数值为16，因此输出16。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>建两种线段树</p>
<p>第一棵求区间最大值，第二种见9棵k进制线段树，求再k进制下的区间和左右区间合并是权值为$x^{len}+y$</p>
<p>还是比较板子的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">&#x27;9&#x27;</span>||ch&lt;<span class="string">&#x27;0&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ret=ret*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">char</span> c[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls x * 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs x * 2 + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,mx;</span><br><span class="line">&#125;t[N * <span class="number">4</span> + <span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l ,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[x].l = l;t[x].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        t[x].mx = c[l] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    t[x].mx = <span class="built_in">max</span>(t[ls].mx, t[rs].mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> id,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[x].l == id &amp;&amp; t[x].r == id)&#123;</span><br><span class="line">        t[x].mx = y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[x].l + t[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(id &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">change</span>(ls, id,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id &gt; mid)&#123;</span><br><span class="line">        <span class="built_in">change</span>(rs,id,y);</span><br><span class="line">    &#125;</span><br><span class="line">    t[x].mx = <span class="built_in">max</span>(t[ls].mx , t[rs].mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span> t[x].mx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[x].l + t[x].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)&#123;</span><br><span class="line">        maxm = <span class="built_in">max</span>(maxm,<span class="built_in">query</span>(ls,l,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)&#123;</span><br><span class="line">        maxm = <span class="built_in">max</span>(maxm,<span class="built_in">query</span>(rs,l,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1000000007</span>;</span><br><span class="line"><span class="function">ll <span class="title">pw</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll re = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            re = re * a % p;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bit</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll sum;</span><br><span class="line">&#125;bt[N * <span class="number">4</span> + <span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitbuild</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r&lt;&lt; endl;</span></span><br><span class="line">    bt[x][b].l = l;</span><br><span class="line">    bt[x][b].r = r;</span><br><span class="line">    <span class="comment">/*if(x == 3)&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; bt[x][b].r &lt;&lt; &quot; &quot; &lt;&lt; bt[x][b].l &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        bt[x][b].sum = c[l] - <span class="string">&#x27;0&#x27;</span>; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bitbuild</span>(ls,l,mid,b);</span><br><span class="line">    <span class="built_in">bitbuild</span>(rs,mid + <span class="number">1</span>,r,b);</span><br><span class="line">    <span class="comment">/*if(x == 1)&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; rs &lt;&lt; &quot; &quot; &lt;&lt; bt[rs][b].r &lt;&lt; &quot; &quot; &lt;&lt; bt[rs][b].l &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">int</span> len = bt[rs][b].r - bt[rs][b].l + <span class="number">1</span>;</span><br><span class="line">    bt[x][b].sum = (bt[ls][b].sum * <span class="built_in">pw</span>(b,len) % p + bt[rs][b].sum) % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitchange</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> id,<span class="keyword">int</span> y,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt[x][b].l == bt[x][b].r &amp;&amp; bt[x][b].r == id)&#123;</span><br><span class="line">        bt[x][b].sum = y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (bt[x][b].l + bt[x][b].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(id &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">bitchange</span>(ls,id,y,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id &gt; mid)&#123;</span><br><span class="line">        <span class="built_in">bitchange</span>(rs,id,y,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = bt[rs][b].r - bt[rs][b].l + <span class="number">1</span>;</span><br><span class="line">    bt[x][b].sum = (bt[ls][b].sum * <span class="built_in">pw</span>(b,len) % p + bt[rs][b].sum) % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">bitquery</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= bt[x][b].l &amp;&amp; bt[x][b].r &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span> bt[x][b].sum % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (bt[x][b].l + bt[x][b].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)&#123;</span><br><span class="line">        sum = <span class="built_in">bitquery</span>(ls,l,r,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; rs &lt;&lt; &quot; &quot; &lt;&lt; bt[rs][x].r &lt;&lt; &quot; &quot; &lt;&lt; bt[rs][x].l &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; endl;</span></span><br><span class="line">        ll sum2 = <span class="built_in">bitquery</span>(rs,l,r,b);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">min</span>(r,bt[rs][b].r)-mid;</span><br><span class="line">        <span class="keyword">return</span> (sum * <span class="built_in">pw</span>(b,len) % p + sum2) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">bitbuild</span>(<span class="number">1</span>,<span class="number">1</span>,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op,x,y;</span><br><span class="line">        op = <span class="built_in">read</span>();x = <span class="built_in">read</span>();y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,x,y);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">                <span class="built_in">bitchange</span>(<span class="number">1</span>,x,y,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mm = <span class="built_in">query</span>(<span class="number">1</span>,x,y);</span><br><span class="line">            mm++;</span><br><span class="line">            <span class="keyword">if</span>(mm == <span class="number">1</span>)&#123;</span><br><span class="line">                mm++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="built_in">bitquery</span>(<span class="number">1</span>,x,y,mm) % p;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            <span class="comment">//printf(&quot;%d\n&quot;,mm);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>重载运算符</title>
    <url>/2021/11/07/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><h5 id="n元运算符后有（n-1-个参数"><a href="#n元运算符后有（n-1-个参数" class="headerlink" title="n元运算符后有（n-1)个参数"></a>n元运算符后有（n-1)个参数</h5><h5 id="自增自减运算符重载"><a href="#自增自减运算符重载" class="headerlink" title="自增自减运算符重载"></a>自增自减运算符重载</h5><p>前置++ – 没有参数 当做一元运算符重载</p>
<p>成员函数</p>
<blockquote>
<p>T &amp; operator++()</p>
</blockquote>
<p>全局函数</p>
<blockquote>
<p>T1 &amp; operator ++ (T2)  //访问类的私有成员可以声明为类的友元函数</p>
</blockquote>
<p>后置++– 有一个参数 当做二元运算符重载</p>
<p>成员函数</p>
<blockquote>
<p>T operator++(int)</p>
</blockquote>
<p>全局函数</p>
<blockquote>
<p>T1 operator++(T2， int)</p>
</blockquote>
<p>从这里看出++i 比 i ++ 要快</p>
<blockquote>
<p>++d 相当于d.operator++()</p>
</blockquote>
<blockquote>
<p>d– 相当于operatior–(d,0)</p>
</blockquote>
<h5 id="c-不能把“-gt-”操作符重载为非成员函数"><a href="#c-不能把“-gt-”操作符重载为非成员函数" class="headerlink" title="c++不能把“= [] () -&gt;”操作符重载为非成员函数"></a>c++不能把“= [] () -&gt;”操作符重载为非成员函数</h5>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>c++</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>错题小店&amp;&amp;小结论</title>
    <url>/2021/09/21/%E9%94%99%E9%A2%98%E5%B0%8F%E5%BA%97&amp;&amp;%E5%B0%8F%E7%BB%93%E8%AE%BA/</url>
    <content><![CDATA[<ol>
<li>运算级</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((a[i]-a[i<span class="number">-1</span>])%x==<span class="number">0</span>)&#123;</span><br><span class="line">	cnt--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是先判括号内部运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i]-a[i<span class="number">-1</span>]%x==<span class="number">0</span>)&#123;</span><br><span class="line">	cnt--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则是先%</p>
<p>附<a href="https://blog.csdn.net/sozzled_/article/details/107057075">优先级表</a></p>
<ol start="2">
<li><p>double 与 printf</p>
<p>结论：在c语言中，double类型的读入必须用”%lf”；输出必须用”%f”</p>
<p>解释：double和float的精度是不同的，故存储空间也是不同的，所以如果要读入double类型，必须要用%lf来读入，以免精度丢失。而输出，由于printf中并无对%lf的严格定义，故使用%lf不一定会出现正确结果。那使用%f输出又如何呢？由于c语言中的默认参数提升规则，%f输出的不论是float还是double都会被提升到双精度进行输出，并不会有精度丢失。</p>
</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>错题</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-7-31</title>
    <url>/2022/07/31/2022-7-31/</url>
    <content><![CDATA[<h2 id="牛客多校round3"><a href="#牛客多校round3" class="headerlink" title="牛客多校round3"></a>牛客多校round3</h2><p>C:签到 本来考虑是trie树，结果直接sort卡常过了</p>
<p>A:easy 处理出来前后缀lca，利用lca可以合并的性质</p>
<p>H：赛中猜测是sam之类的数据结构处理，但是大家都不会QAQ<br>算法和数据结构还需要进一步学习，书到用时方恨少</p>
<p>J: easy，赛中一眼看出dijkstra跑一下就行，但是给出的图转换格式处理了好久，队友用双端队列先过了</p>
<p>总结：进阶的数据结构掌握仍有欠缺，需要抓紧时间学习。除了刷cf的题锻炼思维，还需要刷一些算法专题掌握知识点。</p>
<h2 id="牛客多校round4"><a href="#牛客多校round4" class="headerlink" title="牛客多校round4"></a>牛客多校round4</h2><p>D：一开始就去刚D题了，题目给的生成数据的算法没有说明白，一开始使用错误，生成的数据和样例一直不一样，后来百度现学到了正确的写法，然后把我写的二分交上去发现wa.后来分析发现这道题不满足单调性，然后经过队友提示先通过递推预处理出所有情况，然后o(1)查询成功AC</p>
<p>H: 讨论后发现结果一定是总长的因数，我草草写了暴力验证了一下结论，然后队友猜了个答案成功ac</p>
<p>N 和 K 在赛中没有直接参与做题</p>
<p>赛后补题</p>
<p>k大概是可以重构数组，每位尽可能塞入0或1，然后把重构的数组算方差即可</p>
]]></content>
      <categories>
        <category>训练日志</category>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>训练日志</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-8-7</title>
    <url>/2022/08/07/2022-8-7/</url>
    <content><![CDATA[<h2 id="牛客多校round5"><a href="#牛客多校round5" class="headerlink" title="牛客多校round5"></a>牛客多校round5</h2><p>开始签到题没什么问题，突然弹出unrated，后面题目大量出锅，还有很多原题<br>这场不做评论</p>
<h2 id="牛客多校round6"><a href="#牛客多校round6" class="headerlink" title="牛客多校round6"></a>牛客多校round6</h2><p>J：我先开的J，推了一下公式推出了了，但是因为写法的问题wa了一发，然后化简了一下公式成功AC</p>
<p>G：AC掉J之后开G，<del>没想到在多校打图像输出题</del>，每个单词处理完后一次ac</p>
<p>与此同时 队友A掉了B，树剖+lca</p>
<p>然后开始坐牢，对于M和A大家都没有什么思路，交了几次但是最后也没有写出正确的写法</p>
<p>总结：这场比赛似乎分工有些不明确，J和G在互不知道的情况下我和队友都在写，然后J我wa了一次，队友wa了两次，最后两份代码几乎同时过了，但是白白多了几次罚时。然后是后期没有思路，我对于博弈相关的内容并不很擅长，需要及时补充相关知识点。</p>
]]></content>
      <categories>
        <category>训练日志</category>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>训练日志</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-8-14</title>
    <url>/2022/08/14/2022-8-14/</url>
    <content><![CDATA[<h1 id="round-7"><a href="#round-7" class="headerlink" title="round 7"></a>round 7</h1><p>C:赛中队友开c，我开f</p>
<p>赛后补题:只要把存在的数字位置错排，不存在的任意放即可，是签到题</p>
<p>F：我手写了链表+双指针，赛中没有发现wa原因，赛后发现判断条件放在最前面可以过</p>
<p>G：翻译起来比较麻烦，全队一起看的，经过分析可以发现最长的长度为2，然后通过特判直接得出答案，成功ac</p>
<p>补题：K赛中并没有做出，学习了一下莫队算法<br>奇数的时候有必胜的策略，偶数时谁让堆数-1谁就会输，这样变成了nim游戏，使用莫队离线维护区间异或和不为0可得答案。</p>
<h1 id="round-8"><a href="#round-8" class="headerlink" title="round 8"></a>round 8</h1><p>这场巨难，到最后也只做出1道题，做了4个多小时牢，太菜了QAQ</p>
<p>F：看懂题目第一反应是找循环节，找到一个相同的之后就都一样了，讨论后发现队友思路与我相同，gs写的代码wa了，我看了他的代码发现最后一重循环找到直接break掉了，改成遍历数组取max后ac</p>
<p>总结：一些高级算法还需要学习，面对真正的难题的时候明显感到乏力，平时刷题时要挑战高于自己水平的题目</p>
]]></content>
      <categories>
        <category>训练日志</category>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>训练日志</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第9场The Great Wall II</title>
    <url>/2022/08/16/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC9%E5%9C%BAThe%20Great%20Wall%20II/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定长为 $n$ 的整数序列，将其分为非空的 $k$ 段使得每一段的最大值之和最小，对 $k = 1,2,3…n$ 分别求解。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>定义$dp[i][j]$表示为$[1,i]$中划分了$j$段<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            dp[k][i] = <span class="built_in">min</span>(dp[k][i], dp[k - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="built_in">max_val</span>(j, i));</span><br><span class="line">            <span class="comment">//max_val为a中的区间[j,i]的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的复杂度是$O(n^3)$,对于$n = 8000$ 一定会超时</p>
<p>首先可以发现 $min(dp[k][i], dp[k - 1][j - 1] + max_val(j, i))$是在找多少区间$[j,i]$的最值是$a[i]$</p>
<p>可以通过$O（n^2)$暴力预处理出来前一个比$a[i]$大的数，即$a[pre[i]]$，这样,次数等于k-1时,在$[pre[i],j-1]$的范围内的最大值是$a[pre[i]]$,区间$[j,i]$的最值是$a[i]$<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">    pre[i] = 0;</span><br><span class="line">    for (int j = i - 1; j; j--) &#123;</span><br><span class="line">        if (a[j] &gt; a[i]) &#123;</span><br><span class="line">            pre[i] = j;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于pre[i]之前的数，后面从$pre[i],i]$的最大值都是$a[pre[i]]$<br>所以有</p>
<blockquote>
<p>dp[k - 1][j - 1] + max_val(j, i) = dp[k][pre[i]]</p>
</blockquote>
<p>然后，可以通过线段树或者st表维护dp[k]的区间最小值,将寻找区间最小值优化成log(n)<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int k = 2; k &lt;= n; k++) &#123;</span><br><span class="line">    init(dp[k - 1]);</span><br><span class="line">    for (int i = k; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[k][i] = query(max(k - 1, pre[i]), i - 1) + a[i];</span><br><span class="line">        dp[k][i] = min(dp[k][i], dp[k][pre[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此时的复杂度是$O(n^2log(n))$,在极限数据的情况下仍然可能被卡</p>
<p>实际上之前对于区间的讨论都是在找到最值为a[i]的区间，可以直接通过单调栈来维护<br>因为是通过判断a[i]的大小来push和pop,因此建立一个$pair<int,int>$的栈,第一维存a[i],第二维存dp[k-1][]的最小值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void work() &#123;</span><br><span class="line">    stack&lt;pair&lt;int, int&gt;&gt;stk;//a[i] , mi;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        int minn = dp[k - 1][i - 1];</span><br><span class="line">        while (stk.size() &amp;&amp; stk.top().first &lt;= a[i]) &#123;</span><br><span class="line">            minn = min(stk.top().second, minn);</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        dp[k][i] = min(dp[k][pre[i]], a[i] + minn);</span><br><span class="line">        stk.push(&#123; a[i],minn &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>摘自<br>链接：<a href="https://zhuanlan.zhihu.com/p/554076333">https://zhuanlan.zhihu.com/p/554076333</a><br>作者：严格鸽</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
</search>
